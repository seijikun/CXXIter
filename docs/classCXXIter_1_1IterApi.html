<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CXXIter: CXXIter::IterApi&lt; TSelf &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CXXIter<span id="projectnumber">&#160;0.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classCXXIter_1_1IterApi.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classCXXIter_1_1IterApi-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">CXXIter::IterApi&lt; TSelf &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Public Iterator API surface.  
 <a href="classCXXIter_1_1IterApi.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for CXXIter::IterApi&lt; TSelf &gt;:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="classCXXIter_1_1IterApi__coll__graph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi_1_1iterator.html">iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">C++ iterator implementation for a <a class="el" href="namespaceCXXIter.html" title="CXXIter.">CXXIter</a> chain.  <a href="classCXXIter_1_1IterApi_1_1iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a1ca8ef5efb4a7f873cdcb094e1547e52"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#a1ca8ef5efb4a7f873cdcb094e1547e52">Iterator</a> = <a class="el" href="structCXXIter_1_1trait_1_1Iterator.html">trait::Iterator</a>&lt; TSelf &gt;</td></tr>
<tr class="memdesc:a1ca8ef5efb4a7f873cdcb094e1547e52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the <a class="el" href="structCXXIter_1_1trait_1_1Iterator.html" title="Trait, that is used for the chaining and the operation of iterator pipelines.">trait::Iterator</a> implemenation for this.  <a href="classCXXIter_1_1IterApi.html#a1ca8ef5efb4a7f873cdcb094e1547e52">More...</a><br /></td></tr>
<tr class="separator:a1ca8ef5efb4a7f873cdcb094e1547e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00f3ed5b2201522d327c6a8a92d371c8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a> = typename <a class="el" href="structCXXIter_1_1trait_1_1Iterator.html#a384416c2080e247759c652b17c9c4575">Iterator::Item</a></td></tr>
<tr class="memdesc:a00f3ed5b2201522d327c6a8a92d371c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the elements of this iterator. (Can be references)  <a href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">More...</a><br /></td></tr>
<tr class="separator:a00f3ed5b2201522d327c6a8a92d371c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a628012452f851b7099d919218e2a5512"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#a628012452f851b7099d919218e2a5512">ItemOwned</a> = std::remove_cvref_t&lt; <a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a> &gt;</td></tr>
<tr class="memdesc:a628012452f851b7099d919218e2a5512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Owned Type of the elements of this iterator. (References removed).  <a href="classCXXIter_1_1IterApi.html#a628012452f851b7099d919218e2a5512">More...</a><br /></td></tr>
<tr class="separator:a628012452f851b7099d919218e2a5512"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aaa8bf456c009689898f75879d1691120"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCXXIter_1_1IterApi_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#aaa8bf456c009689898f75879d1691120">begin</a> ()</td></tr>
<tr class="memdesc:aaa8bf456c009689898f75879d1691120"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCXXIter_1_1IterApi.html#aaa8bf456c009689898f75879d1691120" title="begin() method, part of C++&#39;s iterator interface">begin()</a> method, part of C++'s iterator interface  <a href="classCXXIter_1_1IterApi.html#aaa8bf456c009689898f75879d1691120">More...</a><br /></td></tr>
<tr class="separator:aaa8bf456c009689898f75879d1691120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abac1131fb2734cfae22b38099740627a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCXXIter_1_1IterApi_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#abac1131fb2734cfae22b38099740627a">end</a> ()</td></tr>
<tr class="memdesc:abac1131fb2734cfae22b38099740627a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCXXIter_1_1IterApi.html#abac1131fb2734cfae22b38099740627a" title="end() method, part of C++&#39;s iterator interface">end()</a> method, part of C++'s iterator interface  <a href="classCXXIter_1_1IterApi.html#abac1131fb2734cfae22b38099740627a">More...</a><br /></td></tr>
<tr class="separator:abac1131fb2734cfae22b38099740627a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9baddc40de1b9c63102e5c5bf886474e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCXXIter_1_1SizeHint.html">SizeHint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#a9baddc40de1b9c63102e5c5bf886474e">sizeHint</a> () const</td></tr>
<tr class="memdesc:a9baddc40de1b9c63102e5c5bf886474e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the bounds on the remaining length of this iterator, estimated from the source and all of the chained iterations on it.  <a href="classCXXIter_1_1IterApi.html#a9baddc40de1b9c63102e5c5bf886474e">More...</a><br /></td></tr>
<tr class="separator:a9baddc40de1b9c63102e5c5bf886474e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada90a5f5e73ce22a69b21870ee197804"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#ada90a5f5e73ce22a69b21870ee197804">size</a> () const</td></tr>
<tr class="memdesc:ada90a5f5e73ce22a69b21870ee197804"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get this iterator's exact size.  <a href="classCXXIter_1_1IterApi.html#ada90a5f5e73ce22a69b21870ee197804">More...</a><br /></td></tr>
<tr class="separator:ada90a5f5e73ce22a69b21870ee197804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a805fbdc20f9eb42e8162d5eb0a1b3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCXXIter_1_1IterValue.html">IterValue</a>&lt; <a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#a1a805fbdc20f9eb42e8162d5eb0a1b3e">next</a> ()</td></tr>
<tr class="memdesc:a1a805fbdc20f9eb42e8162d5eb0a1b3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next element from this iterator (if any), wrapped in a CXXIter::IterValue&lt;&gt;.  <a href="classCXXIter_1_1IterApi.html#a1a805fbdc20f9eb42e8162d5eb0a1b3e">More...</a><br /></td></tr>
<tr class="separator:a1a805fbdc20f9eb42e8162d5eb0a1b3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab41004a90f1d09365840d58c6dbc76e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#ab41004a90f1d09365840d58c6dbc76e9">advanceBy</a> (size_t n)</td></tr>
<tr class="memdesc:ab41004a90f1d09365840d58c6dbc76e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance the iterator by n elements.  <a href="classCXXIter_1_1IterApi.html#ab41004a90f1d09365840d58c6dbc76e9">More...</a><br /></td></tr>
<tr class="separator:ab41004a90f1d09365840d58c6dbc76e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f1f0e435b605b4947eea18fa4762ca0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCXXIter_1_1IterValue.html">IterValue</a>&lt; <a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#a7f1f0e435b605b4947eea18fa4762ca0">nextBack</a> ()</td></tr>
<tr class="memdesc:a7f1f0e435b605b4947eea18fa4762ca0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next element from the back of this iterator (if any), wrapped in a CXXIter::IterValue&lt;&gt;.  <a href="classCXXIter_1_1IterApi.html#a7f1f0e435b605b4947eea18fa4762ca0">More...</a><br /></td></tr>
<tr class="separator:a7f1f0e435b605b4947eea18fa4762ca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Consumers</div></td></tr>
<tr class="memitem:aad1cbb262290264fc2e12d80492ad066"><td class="memTemplParams" colspan="2">template&lt;typename TUseFn &gt; </td></tr>
<tr class="memitem:aad1cbb262290264fc2e12d80492ad066"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#aad1cbb262290264fc2e12d80492ad066">forEach</a> (TUseFn useFn)</td></tr>
<tr class="memdesc:aad1cbb262290264fc2e12d80492ad066"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consumer that calls the given function <code>useFn</code> for each of the elements in this iterator.  <a href="classCXXIter_1_1IterApi.html#aad1cbb262290264fc2e12d80492ad066">More...</a><br /></td></tr>
<tr class="separator:aad1cbb262290264fc2e12d80492ad066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a294c5e7bc59f4e4c5d7e40b96dff3a89"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename... &gt; typename TTargetContainer, typename... TTargetContainerArgs&gt; </td></tr>
<tr class="memitem:a294c5e7bc59f4e4c5d7e40b96dff3a89"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#a294c5e7bc59f4e4c5d7e40b96dff3a89">collect</a> ()</td></tr>
<tr class="memdesc:a294c5e7bc59f4e4c5d7e40b96dff3a89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consumer that collects all elements from this iterator in a new container of type <code>TTargetContainer</code>.  <a href="classCXXIter_1_1IterApi.html#a294c5e7bc59f4e4c5d7e40b96dff3a89">More...</a><br /></td></tr>
<tr class="separator:a294c5e7bc59f4e4c5d7e40b96dff3a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af624739bd9e8e235500273f5a9465544"><td class="memTemplParams" colspan="2">template&lt;typename TTargetContainer &gt; </td></tr>
<tr class="memitem:af624739bd9e8e235500273f5a9465544"><td class="memTemplItemLeft" align="right" valign="top">TTargetContainer&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#af624739bd9e8e235500273f5a9465544">collect</a> ()</td></tr>
<tr class="memdesc:af624739bd9e8e235500273f5a9465544"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consumer that collects all elements from this iterator in a new container of type <code>TTargetContainer</code>.  <a href="classCXXIter_1_1IterApi.html#af624739bd9e8e235500273f5a9465544">More...</a><br /></td></tr>
<tr class="separator:af624739bd9e8e235500273f5a9465544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9f60e619bcb3f2f5728605e5738854c"><td class="memTemplParams" colspan="2">template&lt;typename TTargetContainer &gt; </td></tr>
<tr class="memitem:ab9f60e619bcb3f2f5728605e5738854c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#ab9f60e619bcb3f2f5728605e5738854c">collectInto</a> (TTargetContainer &amp;container)</td></tr>
<tr class="memdesc:ab9f60e619bcb3f2f5728605e5738854c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consumer that collects all elements from this iterator into the given <code>container</code>.  <a href="classCXXIter_1_1IterApi.html#ab9f60e619bcb3f2f5728605e5738854c">More...</a><br /></td></tr>
<tr class="separator:ab9f60e619bcb3f2f5728605e5738854c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16bc04471483e7ce71726036befa551e"><td class="memTemplParams" colspan="2">template&lt;typename TResult , std::invocable&lt; TResult &amp;, <a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a> &amp;&amp; &gt; FoldFn&gt; </td></tr>
<tr class="memitem:a16bc04471483e7ce71726036befa551e"><td class="memTemplItemLeft" align="right" valign="top">TResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#a16bc04471483e7ce71726036befa551e">fold</a> (TResult startValue, FoldFn foldFn)</td></tr>
<tr class="memdesc:a16bc04471483e7ce71726036befa551e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consumer that executes the given <code>foldFn</code> for each item in this iterator, to apply to a working value, which is passed on and passed as second argument to the next call to <code>foldFn</code>.  <a href="classCXXIter_1_1IterApi.html#a16bc04471483e7ce71726036befa551e">More...</a><br /></td></tr>
<tr class="separator:a16bc04471483e7ce71726036befa551e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d6aae5cb3890b2a21bb2d30cd55623d"><td class="memTemplParams" colspan="2">template&lt;std::invocable&lt; const <a class="el" href="classCXXIter_1_1IterApi.html#a628012452f851b7099d919218e2a5512">ItemOwned</a> &amp; &gt; TPredicateFn&gt; <br />
requires std::same_as&lt;std::invoke_result_t&lt;TPredicateFn, const <a class="el" href="classCXXIter_1_1IterApi.html#a628012452f851b7099d919218e2a5512">ItemOwned</a>&amp;&gt;, bool&gt;</td></tr>
<tr class="memitem:a6d6aae5cb3890b2a21bb2d30cd55623d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#a6d6aae5cb3890b2a21bb2d30cd55623d">all</a> (TPredicateFn predicateFn)</td></tr>
<tr class="memdesc:a6d6aae5cb3890b2a21bb2d30cd55623d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests if all elements of this iterator match the given <code>predicateFn</code>.  <a href="classCXXIter_1_1IterApi.html#a6d6aae5cb3890b2a21bb2d30cd55623d">More...</a><br /></td></tr>
<tr class="separator:a6d6aae5cb3890b2a21bb2d30cd55623d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27ea52a9390e9127a7fafd760a68fc0c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#a27ea52a9390e9127a7fafd760a68fc0c">all</a> ()</td></tr>
<tr class="memdesc:a27ea52a9390e9127a7fafd760a68fc0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests if all elements of this iterator yield the value <code>true</code> when casted to <code>bool</code>.  <a href="classCXXIter_1_1IterApi.html#a27ea52a9390e9127a7fafd760a68fc0c">More...</a><br /></td></tr>
<tr class="separator:a27ea52a9390e9127a7fafd760a68fc0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a233794e7bcf62f21de8f66cff22750b0"><td class="memTemplParams" colspan="2">template&lt;std::invocable&lt; const <a class="el" href="classCXXIter_1_1IterApi.html#a628012452f851b7099d919218e2a5512">ItemOwned</a> &amp; &gt; TPredicateFn&gt; </td></tr>
<tr class="memitem:a233794e7bcf62f21de8f66cff22750b0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#a233794e7bcf62f21de8f66cff22750b0">any</a> (TPredicateFn predicateFn)</td></tr>
<tr class="memdesc:a233794e7bcf62f21de8f66cff22750b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests if any of the elements of this iterator match the given <code>predicateFn</code>.  <a href="classCXXIter_1_1IterApi.html#a233794e7bcf62f21de8f66cff22750b0">More...</a><br /></td></tr>
<tr class="separator:a233794e7bcf62f21de8f66cff22750b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f621d583ff137b6537eff24d96b2c18"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#a4f621d583ff137b6537eff24d96b2c18">any</a> ()</td></tr>
<tr class="memdesc:a4f621d583ff137b6537eff24d96b2c18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests if any of the elements of this iterator yield the value <code>true</code> when casted to <code>bool</code>.  <a href="classCXXIter_1_1IterApi.html#a4f621d583ff137b6537eff24d96b2c18">More...</a><br /></td></tr>
<tr class="separator:a4f621d583ff137b6537eff24d96b2c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8842d23b1b30accf123e096fb7aae099"><td class="memItemLeft" align="right" valign="top">std::optional&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#a8842d23b1b30accf123e096fb7aae099">findIdx</a> (const <a class="el" href="classCXXIter_1_1IterApi.html#a628012452f851b7099d919218e2a5512">ItemOwned</a> &amp;searchItem)</td></tr>
<tr class="memdesc:a8842d23b1b30accf123e096fb7aae099"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for the given <code>searchItem</code> within the items of this iterator, and return the index of the first item from the iterator that is equal to the given <code>searchItem</code>.  <a href="classCXXIter_1_1IterApi.html#a8842d23b1b30accf123e096fb7aae099">More...</a><br /></td></tr>
<tr class="separator:a8842d23b1b30accf123e096fb7aae099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36e35fb8446e4c302e48a0a3b2cdca86"><td class="memTemplParams" colspan="2">template&lt;std::invocable&lt; const <a class="el" href="classCXXIter_1_1IterApi.html#a628012452f851b7099d919218e2a5512">ItemOwned</a> &amp; &gt; TFindFn&gt; </td></tr>
<tr class="memitem:a36e35fb8446e4c302e48a0a3b2cdca86"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; size_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#a36e35fb8446e4c302e48a0a3b2cdca86">findIdx</a> (TFindFn findFn)</td></tr>
<tr class="memdesc:a36e35fb8446e4c302e48a0a3b2cdca86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for the iterator with the given <code>findFn</code>, and return the index of the element from this iterator, for which the <code>findFn</code> returned <code>true</code> the first time.  <a href="classCXXIter_1_1IterApi.html#a36e35fb8446e4c302e48a0a3b2cdca86">More...</a><br /></td></tr>
<tr class="separator:a36e35fb8446e4c302e48a0a3b2cdca86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab44325cb6ee35f352ca90c33db720644"><td class="memTemplParams" colspan="2">template&lt;std::invocable&lt; const <a class="el" href="classCXXIter_1_1IterApi.html#a628012452f851b7099d919218e2a5512">ItemOwned</a> &amp; &gt; TFindFn&gt; </td></tr>
<tr class="memitem:ab44325cb6ee35f352ca90c33db720644"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCXXIter_1_1IterValue.html">IterValue</a>&lt; <a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#ab44325cb6ee35f352ca90c33db720644">find</a> (TFindFn findFn)</td></tr>
<tr class="memdesc:ab44325cb6ee35f352ca90c33db720644"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for an element of this iterator, that satisfies the given <code>findFn</code> predicate.  <a href="classCXXIter_1_1IterApi.html#ab44325cb6ee35f352ca90c33db720644">More...</a><br /></td></tr>
<tr class="separator:ab44325cb6ee35f352ca90c33db720644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a418901ce726860a7a91bffbc210c1815"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#a418901ce726860a7a91bffbc210c1815">count</a> ()</td></tr>
<tr class="memdesc:a418901ce726860a7a91bffbc210c1815"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consumer that counts the elements in this iterator.  <a href="classCXXIter_1_1IterApi.html#a418901ce726860a7a91bffbc210c1815">More...</a><br /></td></tr>
<tr class="separator:a418901ce726860a7a91bffbc210c1815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd58d36cbf83360cd7a6959971e2ef6"><td class="memTemplParams" colspan="2">template&lt;std::invocable&lt; const <a class="el" href="classCXXIter_1_1IterApi.html#a628012452f851b7099d919218e2a5512">ItemOwned</a> &amp; &gt; TPredicateFn&gt; </td></tr>
<tr class="memitem:abfd58d36cbf83360cd7a6959971e2ef6"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#abfd58d36cbf83360cd7a6959971e2ef6">count</a> (TPredicateFn predicateFn)</td></tr>
<tr class="memdesc:abfd58d36cbf83360cd7a6959971e2ef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consumer that counts the elements in this iterator, for which the given <code>predicateFn</code> returns <code>true</code>.  <a href="classCXXIter_1_1IterApi.html#abfd58d36cbf83360cd7a6959971e2ef6">More...</a><br /></td></tr>
<tr class="separator:abfd58d36cbf83360cd7a6959971e2ef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc37b3e2bc9c3417d29ff713e27111e1"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#afc37b3e2bc9c3417d29ff713e27111e1">count</a> (const <a class="el" href="classCXXIter_1_1IterApi.html#a628012452f851b7099d919218e2a5512">ItemOwned</a> &amp;countItem)</td></tr>
<tr class="memdesc:afc37b3e2bc9c3417d29ff713e27111e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consumer that counts the occurences of <code>countItem</code> within this iterator.  <a href="classCXXIter_1_1IterApi.html#afc37b3e2bc9c3417d29ff713e27111e1">More...</a><br /></td></tr>
<tr class="separator:afc37b3e2bc9c3417d29ff713e27111e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69c182f266a918168975a3764a1fc8eb"><td class="memTemplParams" colspan="2">template&lt;typename TResult  = ItemOwned&gt; <br />
requires requires(TResult res, <a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a> item) { { res += item }; }</td></tr>
<tr class="memitem:a69c182f266a918168975a3764a1fc8eb"><td class="memTemplItemLeft" align="right" valign="top">TResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#a69c182f266a918168975a3764a1fc8eb">sum</a> (TResult startValue=TResult())</td></tr>
<tr class="memdesc:a69c182f266a918168975a3764a1fc8eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consumer that calculates the sum of all elements from this iterator.  <a href="classCXXIter_1_1IterApi.html#a69c182f266a918168975a3764a1fc8eb">More...</a><br /></td></tr>
<tr class="separator:a69c182f266a918168975a3764a1fc8eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5674bb7c86728cc2520d7b3bebea437"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#ab5674bb7c86728cc2520d7b3bebea437">stringJoin</a> (const std::string &amp;separator)</td></tr>
<tr class="memdesc:ab5674bb7c86728cc2520d7b3bebea437"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consumer that concatenates the elements of this iterator to a large <code>std::string</code> , where each element is separated by the specified <code>separator</code>.  <a href="classCXXIter_1_1IterApi.html#ab5674bb7c86728cc2520d7b3bebea437">More...</a><br /></td></tr>
<tr class="separator:ab5674bb7c86728cc2520d7b3bebea437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1727767f03cfe2be17ea017e87beb7ab"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceCXXIter.html#a4e698a5b11eca24990a5db359a5e58ec">StatisticNormalization</a> NORM = StatisticNormalization::N, typename TResult  = ItemOwned, typename TCount  = ItemOwned&gt; </td></tr>
<tr class="memitem:a1727767f03cfe2be17ea017e87beb7ab"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; TResult &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#a1727767f03cfe2be17ea017e87beb7ab">mean</a> (TResult sumStart=TResult())</td></tr>
<tr class="memdesc:a1727767f03cfe2be17ea017e87beb7ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consumer that calculates the mean of all elements of this iterator.  <a href="classCXXIter_1_1IterApi.html#a1727767f03cfe2be17ea017e87beb7ab">More...</a><br /></td></tr>
<tr class="separator:a1727767f03cfe2be17ea017e87beb7ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5445e417abd242adfc7a3e378bcc9036"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceCXXIter.html#a4e698a5b11eca24990a5db359a5e58ec">StatisticNormalization</a> NORM = StatisticNormalization::N, typename TResult  = ItemOwned, typename TCount  = ItemOwned&gt; </td></tr>
<tr class="memitem:a5445e417abd242adfc7a3e378bcc9036"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; TResult &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#a5445e417abd242adfc7a3e378bcc9036">variance</a> ()</td></tr>
<tr class="memdesc:a5445e417abd242adfc7a3e378bcc9036"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consumer that calculates the variance of all elements of this iterator.  <a href="classCXXIter_1_1IterApi.html#a5445e417abd242adfc7a3e378bcc9036">More...</a><br /></td></tr>
<tr class="separator:a5445e417abd242adfc7a3e378bcc9036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83370ed3a2770da9e4b5aa7317534487"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceCXXIter.html#a4e698a5b11eca24990a5db359a5e58ec">StatisticNormalization</a> NORM = StatisticNormalization::N, typename TResult  = ItemOwned, typename TCount  = ItemOwned&gt; </td></tr>
<tr class="memitem:a83370ed3a2770da9e4b5aa7317534487"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; TResult &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#a83370ed3a2770da9e4b5aa7317534487">stddev</a> ()</td></tr>
<tr class="memdesc:a83370ed3a2770da9e4b5aa7317534487"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consumer that calculates the standard deviation of all elements of this iterator.  <a href="classCXXIter_1_1IterApi.html#a83370ed3a2770da9e4b5aa7317534487">More...</a><br /></td></tr>
<tr class="separator:a83370ed3a2770da9e4b5aa7317534487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cf454fb870bc6d782f5f4a392c39520"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCXXIter_1_1IterValue.html">IterValue</a>&lt; <a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#a8cf454fb870bc6d782f5f4a392c39520">min</a> ()</td></tr>
<tr class="memdesc:a8cf454fb870bc6d782f5f4a392c39520"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consumer that yields the smallest element from this iterator.  <a href="classCXXIter_1_1IterApi.html#a8cf454fb870bc6d782f5f4a392c39520">More...</a><br /></td></tr>
<tr class="separator:a8cf454fb870bc6d782f5f4a392c39520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad191096d655db542272acc7b89f76962"><td class="memItemLeft" align="right" valign="top">std::optional&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#ad191096d655db542272acc7b89f76962">minIdx</a> ()</td></tr>
<tr class="memdesc:ad191096d655db542272acc7b89f76962"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consumer that yields the index of the smallest element within this iterator.  <a href="classCXXIter_1_1IterApi.html#ad191096d655db542272acc7b89f76962">More...</a><br /></td></tr>
<tr class="separator:ad191096d655db542272acc7b89f76962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab269288401b9ace95379eb94bc3a1dfe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCXXIter_1_1IterValue.html">IterValue</a>&lt; <a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#ab269288401b9ace95379eb94bc3a1dfe">max</a> ()</td></tr>
<tr class="memdesc:ab269288401b9ace95379eb94bc3a1dfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consumer that yields the largest element from this iterator.  <a href="classCXXIter_1_1IterApi.html#ab269288401b9ace95379eb94bc3a1dfe">More...</a><br /></td></tr>
<tr class="separator:ab269288401b9ace95379eb94bc3a1dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af161ffefa2006ad6df0bd084d7374f51"><td class="memItemLeft" align="right" valign="top">std::optional&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#af161ffefa2006ad6df0bd084d7374f51">maxIdx</a> ()</td></tr>
<tr class="memdesc:af161ffefa2006ad6df0bd084d7374f51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consumer that yields the index of the largest element within this iterator.  <a href="classCXXIter_1_1IterApi.html#af161ffefa2006ad6df0bd084d7374f51">More...</a><br /></td></tr>
<tr class="separator:af161ffefa2006ad6df0bd084d7374f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b119a582aeea0e05e9d6985c4439983"><td class="memTemplParams" colspan="2">template&lt;typename TCompValueExtractFn &gt; <br />
requires requires(const std::invoke_result_t&lt;TCompValueExtractFn, <a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a>&amp;&amp;&gt;&amp; a, std::remove_cvref_t&lt;decltype(a)&gt; ownedA) { { a &lt; a }; { ownedA = ownedA }; }</td></tr>
<tr class="memitem:a2b119a582aeea0e05e9d6985c4439983"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCXXIter_1_1IterValue.html">IterValue</a>&lt; <a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#a2b119a582aeea0e05e9d6985c4439983">minBy</a> (TCompValueExtractFn compValueExtractFn)</td></tr>
<tr class="memdesc:a2b119a582aeea0e05e9d6985c4439983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consumer that yields the smallest element from this iterator. Comparison of items is done using the comparison values returned by invoking the given <code>compValueExtractFn</code> on each element.  <a href="classCXXIter_1_1IterApi.html#a2b119a582aeea0e05e9d6985c4439983">More...</a><br /></td></tr>
<tr class="separator:a2b119a582aeea0e05e9d6985c4439983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af531c69c1b5edf6d5c30c56ddd0c9500"><td class="memTemplParams" colspan="2">template&lt;typename TCompValueExtractFn &gt; <br />
requires requires(const std::invoke_result_t&lt;TCompValueExtractFn, <a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a>&amp;&amp;&gt;&amp; a) { { a &lt; a }; }</td></tr>
<tr class="memitem:af531c69c1b5edf6d5c30c56ddd0c9500"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; size_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#af531c69c1b5edf6d5c30c56ddd0c9500">minIdxBy</a> (TCompValueExtractFn compValueExtractFn)</td></tr>
<tr class="memdesc:af531c69c1b5edf6d5c30c56ddd0c9500"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consumer that yields the index of the smallest element from this iterator. Comparison of items is done using the comparison values returned by invoking the given <code>compValueExtractFn</code> on each element.  <a href="classCXXIter_1_1IterApi.html#af531c69c1b5edf6d5c30c56ddd0c9500">More...</a><br /></td></tr>
<tr class="separator:af531c69c1b5edf6d5c30c56ddd0c9500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab52a8aecfbfa75c7ab5606628831687e"><td class="memTemplParams" colspan="2">template&lt;typename TMaxValueExtractFn &gt; <br />
requires requires(const std::invoke_result_t&lt;TMaxValueExtractFn, <a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a>&amp;&amp;&gt;&amp; a, std::remove_cvref_t&lt;decltype(a)&gt; ownedA) { { a &gt; a }; { ownedA = ownedA }; }</td></tr>
<tr class="memitem:ab52a8aecfbfa75c7ab5606628831687e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCXXIter_1_1IterValue.html">IterValue</a>&lt; <a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#ab52a8aecfbfa75c7ab5606628831687e">maxBy</a> (TMaxValueExtractFn compValueExtractFn)</td></tr>
<tr class="memdesc:ab52a8aecfbfa75c7ab5606628831687e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consumer that yields the largest element from this iterator. Comparison of items is done using the comparison values returned by invoking the given <code>compValueExtractFn</code> on each element.  <a href="classCXXIter_1_1IterApi.html#ab52a8aecfbfa75c7ab5606628831687e">More...</a><br /></td></tr>
<tr class="separator:ab52a8aecfbfa75c7ab5606628831687e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61dd9812e764db7f0acbc1509cea21ad"><td class="memTemplParams" colspan="2">template&lt;typename TMaxValueExtractFn &gt; <br />
requires requires(const std::invoke_result_t&lt;TMaxValueExtractFn, <a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a>&amp;&amp;&gt;&amp; a, std::remove_cvref_t&lt;decltype(a)&gt; ownedA) { { a &gt; a }; { ownedA = ownedA }; }</td></tr>
<tr class="memitem:a61dd9812e764db7f0acbc1509cea21ad"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; size_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#a61dd9812e764db7f0acbc1509cea21ad">maxIdxBy</a> (TMaxValueExtractFn compValueExtractFn)</td></tr>
<tr class="memdesc:a61dd9812e764db7f0acbc1509cea21ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consumer that yields the index of the largest element from this iterator. Comparison of items is done using the comparison values returned by invoking the given <code>TCompValueExtractFn</code> on each element.  <a href="classCXXIter_1_1IterApi.html#a61dd9812e764db7f0acbc1509cea21ad">More...</a><br /></td></tr>
<tr class="separator:a61dd9812e764db7f0acbc1509cea21ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac706806233525343ea38dc7e78f2faeb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCXXIter_1_1IterValue.html">IterValue</a>&lt; <a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#ac706806233525343ea38dc7e78f2faeb">last</a> ()</td></tr>
<tr class="memdesc:ac706806233525343ea38dc7e78f2faeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consumer that yields the last element of this iterator.  <a href="classCXXIter_1_1IterApi.html#ac706806233525343ea38dc7e78f2faeb">More...</a><br /></td></tr>
<tr class="separator:ac706806233525343ea38dc7e78f2faeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0d21f64c103c94930a6965686f61019"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCXXIter_1_1IterValue.html">IterValue</a>&lt; <a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#aa0d21f64c103c94930a6965686f61019">nth</a> (size_t n)</td></tr>
<tr class="memdesc:aa0d21f64c103c94930a6965686f61019"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the <code></code>{n}-th element from this iterator (if available).  <a href="classCXXIter_1_1IterApi.html#aa0d21f64c103c94930a6965686f61019">More...</a><br /></td></tr>
<tr class="separator:aa0d21f64c103c94930a6965686f61019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Chainers</div></td></tr>
<tr class="memitem:a4d7e8944accd23e1175e685d34010306"><td class="memTemplParams" colspan="2">template&lt;typename TItemOutput &gt; </td></tr>
<tr class="memitem:a4d7e8944accd23e1175e685d34010306"><td class="memTemplItemLeft" align="right" valign="top">op::Caster&lt; TSelf, TItemOutput &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#a4d7e8944accd23e1175e685d34010306">cast</a> ()</td></tr>
<tr class="memdesc:a4d7e8944accd23e1175e685d34010306"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new iterator that casts the elements of this iterator to the type requested by <code>TItemOutput</code>.  <a href="classCXXIter_1_1IterApi.html#a4d7e8944accd23e1175e685d34010306">More...</a><br /></td></tr>
<tr class="separator:a4d7e8944accd23e1175e685d34010306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a116afb3640cb245742403c86fded359f"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#a116afb3640cb245742403c86fded359f">copied</a> ()</td></tr>
<tr class="memdesc:a116afb3640cb245742403c86fded359f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new iterator that copies the elements of this iterator.  <a href="classCXXIter_1_1IterApi.html#a116afb3640cb245742403c86fded359f">More...</a><br /></td></tr>
<tr class="separator:a116afb3640cb245742403c86fded359f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a037dc6c6a07bbda8b580ef9ea266db08"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#a037dc6c6a07bbda8b580ef9ea266db08">indexed</a> ()</td></tr>
<tr class="memdesc:a037dc6c6a07bbda8b580ef9ea266db08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new iterator that tags each element of this iterator with the corresponding index, stored in a <code>std::pair</code>.  <a href="classCXXIter_1_1IterApi.html#a037dc6c6a07bbda8b580ef9ea266db08">More...</a><br /></td></tr>
<tr class="separator:a037dc6c6a07bbda8b580ef9ea266db08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20aea92a66ad20c05d914944968d4f26"><td class="memItemLeft" align="right" valign="top">op::FlagLast&lt; TSelf &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#a20aea92a66ad20c05d914944968d4f26">flagLast</a> ()</td></tr>
<tr class="memdesc:a20aea92a66ad20c05d914944968d4f26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new iterator that tags each element with a boolean value specifying whether the element is the last one in the iterator. Boolean and actual iterator element are stored in a <code>std::pair</code>.  <a href="classCXXIter_1_1IterApi.html#a20aea92a66ad20c05d914944968d4f26">More...</a><br /></td></tr>
<tr class="separator:a20aea92a66ad20c05d914944968d4f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fe973bcef3669050b734c6c0c0481bb"><td class="memTemplParams" colspan="2">template&lt;std::invocable&lt; const <a class="el" href="classCXXIter_1_1IterApi.html#a628012452f851b7099d919218e2a5512">ItemOwned</a> &amp; &gt; TFilterFn&gt; </td></tr>
<tr class="memitem:a6fe973bcef3669050b734c6c0c0481bb"><td class="memTemplItemLeft" align="right" valign="top">op::Filter&lt; TSelf, TFilterFn &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#a6fe973bcef3669050b734c6c0c0481bb">filter</a> (TFilterFn filterFn)</td></tr>
<tr class="memdesc:a6fe973bcef3669050b734c6c0c0481bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new iterator that only contains the elements from this iterator, for which the given <code>filterFn</code> returned <code>true</code>.  <a href="classCXXIter_1_1IterApi.html#a6fe973bcef3669050b734c6c0c0481bb">More...</a><br /></td></tr>
<tr class="separator:a6fe973bcef3669050b734c6c0c0481bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae692e23a444ce5a9f484ae959cd3bf7b"><td class="memTemplParams" colspan="2">template&lt;std::invocable&lt; const <a class="el" href="classCXXIter_1_1IterApi.html#a628012452f851b7099d919218e2a5512">ItemOwned</a> &amp; &gt; TMapFn&gt; <br />
requires util::is_hashable&lt;std::invoke_result_t&lt;TMapFn, const <a class="el" href="classCXXIter_1_1IterApi.html#a628012452f851b7099d919218e2a5512">ItemOwned</a>&amp;&gt;&gt;</td></tr>
<tr class="memitem:ae692e23a444ce5a9f484ae959cd3bf7b"><td class="memTemplItemLeft" align="right" valign="top">op::Unique&lt; TSelf, TMapFn &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#ae692e23a444ce5a9f484ae959cd3bf7b">unique</a> (TMapFn mapFn)</td></tr>
<tr class="memdesc:ae692e23a444ce5a9f484ae959cd3bf7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new iterator that only contains every element of the input iterator only once.  <a href="classCXXIter_1_1IterApi.html#ae692e23a444ce5a9f484ae959cd3bf7b">More...</a><br /></td></tr>
<tr class="separator:ae692e23a444ce5a9f484ae959cd3bf7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c3a1a50ce87f94bbeb146897248e6f2"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#a7c3a1a50ce87f94bbeb146897248e6f2">unique</a> ()</td></tr>
<tr class="memdesc:a7c3a1a50ce87f94bbeb146897248e6f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new iterator that only contains every element of the input iterator only once.  <a href="classCXXIter_1_1IterApi.html#a7c3a1a50ce87f94bbeb146897248e6f2">More...</a><br /></td></tr>
<tr class="separator:a7c3a1a50ce87f94bbeb146897248e6f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac63528dd525977d236a3c3b050ed1456"><td class="memItemLeft" align="right" valign="top">op::Reverse&lt; TSelf &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#ac63528dd525977d236a3c3b050ed1456">reverse</a> ()</td></tr>
<tr class="memdesc:ac63528dd525977d236a3c3b050ed1456"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new iterator that provides the elements of this iterator in reverse order.  <a href="classCXXIter_1_1IterApi.html#ac63528dd525977d236a3c3b050ed1456">More...</a><br /></td></tr>
<tr class="separator:ac63528dd525977d236a3c3b050ed1456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4a7ab60181e939f57eb56373c5a2bbe"><td class="memTemplParams" colspan="2">template&lt;const size_t CHUNK_SIZE&gt; </td></tr>
<tr class="memitem:ad4a7ab60181e939f57eb56373c5a2bbe"><td class="memTemplItemLeft" align="right" valign="top">op::Chunked&lt; TSelf, CHUNK_SIZE &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#ad4a7ab60181e939f57eb56373c5a2bbe">chunked</a> ()</td></tr>
<tr class="memdesc:ad4a7ab60181e939f57eb56373c5a2bbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new iterator that collects elements from this iterator in chunks of size up to <code>CHUNK_SIZE</code>, which then constitue the elements of the new iterator.  <a href="classCXXIter_1_1IterApi.html#ad4a7ab60181e939f57eb56373c5a2bbe">More...</a><br /></td></tr>
<tr class="separator:ad4a7ab60181e939f57eb56373c5a2bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa100f6d93caf6b3537535df3a4a81e32"><td class="memTemplParams" colspan="2">template&lt;const size_t CHUNK_SIZE, const size_t STEP_SIZE = CHUNK_SIZE&gt; </td></tr>
<tr class="memitem:aa100f6d93caf6b3537535df3a4a81e32"><td class="memTemplItemLeft" align="right" valign="top">op::ChunkedExact&lt; TSelf, CHUNK_SIZE, STEP_SIZE &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#aa100f6d93caf6b3537535df3a4a81e32">chunkedExact</a> ()</td></tr>
<tr class="memdesc:aa100f6d93caf6b3537535df3a4a81e32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new iterator that collects elements from this iterator in exact-sized chunks of <code>CHUNK_SIZE</code>, which then constitue the elements of the new iterator.  <a href="classCXXIter_1_1IterApi.html#aa100f6d93caf6b3537535df3a4a81e32">More...</a><br /></td></tr>
<tr class="separator:aa100f6d93caf6b3537535df3a4a81e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8f3454d96494c248abf2e740442e6b6"><td class="memTemplParams" colspan="2">template&lt;std::invocable&lt; <a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a> &amp;&amp; &gt; TMapFn&gt; </td></tr>
<tr class="memitem:ad8f3454d96494c248abf2e740442e6b6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#ad8f3454d96494c248abf2e740442e6b6">map</a> (TMapFn mapFn)</td></tr>
<tr class="memdesc:ad8f3454d96494c248abf2e740442e6b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an iterator that uses the given <code>mapFn</code> to map each element from this iterator to elements of the new iterator.  <a href="classCXXIter_1_1IterApi.html#ad8f3454d96494c248abf2e740442e6b6">More...</a><br /></td></tr>
<tr class="separator:ad8f3454d96494c248abf2e740442e6b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a165695af4dc2acf1cf6eadd3ae6c2fc2"><td class="memTemplParams" colspan="2">template&lt;std::invocable&lt; <a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a> &amp;&amp; &gt; TFlatMapFn&gt; </td></tr>
<tr class="memitem:a165695af4dc2acf1cf6eadd3ae6c2fc2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#a165695af4dc2acf1cf6eadd3ae6c2fc2">flatMap</a> (TFlatMapFn mapFn)</td></tr>
<tr class="memdesc:a165695af4dc2acf1cf6eadd3ae6c2fc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an iterator that works like <a class="el" href="classCXXIter_1_1IterApi.html#ad8f3454d96494c248abf2e740442e6b6" title="Creates an iterator that uses the given mapFn to map each element from this iterator to elements of t...">map()</a>, but flattens nested containers.  <a href="classCXXIter_1_1IterApi.html#a165695af4dc2acf1cf6eadd3ae6c2fc2">More...</a><br /></td></tr>
<tr class="separator:a165695af4dc2acf1cf6eadd3ae6c2fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a859ed47310bc0aade5e6d4378433ac84"><td class="memTemplParams" colspan="2">template&lt;GeneratorFromFunction&lt; <a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a> &gt; TGeneratorFn&gt; </td></tr>
<tr class="memitem:a859ed47310bc0aade5e6d4378433ac84"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#a859ed47310bc0aade5e6d4378433ac84">generateFrom</a> (TGeneratorFn generatorFn)</td></tr>
<tr class="memdesc:a859ed47310bc0aade5e6d4378433ac84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new iterator containing the items that the given generator produces for each element in this iterator.  <a href="classCXXIter_1_1IterApi.html#a859ed47310bc0aade5e6d4378433ac84">More...</a><br /></td></tr>
<tr class="separator:a859ed47310bc0aade5e6d4378433ac84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8985f7682655e5a925329fcd971b482"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#ad8985f7682655e5a925329fcd971b482">flatMap</a> ()</td></tr>
<tr class="memdesc:ad8985f7682655e5a925329fcd971b482"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an iterator that flattens the iterable elements of this iterator.  <a href="classCXXIter_1_1IterApi.html#ad8985f7682655e5a925329fcd971b482">More...</a><br /></td></tr>
<tr class="separator:ad8985f7682655e5a925329fcd971b482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1dfa465e7f30e6d8d4fadabd8b092b4"><td class="memTemplParams" colspan="2">template&lt;std::invocable&lt; <a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a> &amp; &gt; TModifierFn&gt; </td></tr>
<tr class="memitem:ab1dfa465e7f30e6d8d4fadabd8b092b4"><td class="memTemplItemLeft" align="right" valign="top">op::InplaceModifier&lt; TSelf, TModifierFn &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#ab1dfa465e7f30e6d8d4fadabd8b092b4">modify</a> (TModifierFn modifierFn)</td></tr>
<tr class="memdesc:ab1dfa465e7f30e6d8d4fadabd8b092b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to inspect and modify each item in-place, that passes through this iterator.  <a href="classCXXIter_1_1IterApi.html#ab1dfa465e7f30e6d8d4fadabd8b092b4">More...</a><br /></td></tr>
<tr class="separator:ab1dfa465e7f30e6d8d4fadabd8b092b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5197ae490a155c204cf6f6faddcbf10"><td class="memTemplParams" colspan="2">template&lt;std::invocable&lt; <a class="el" href="classCXXIter_1_1IterApi.html#a628012452f851b7099d919218e2a5512">ItemOwned</a> &amp;&amp; &gt; TFilterMapFn&gt; <br />
requires util::is_optional&lt;std::invoke_result_t&lt;TFilterMapFn, <a class="el" href="classCXXIter_1_1IterApi.html#a628012452f851b7099d919218e2a5512">ItemOwned</a>&amp;&amp;&gt;&gt;</td></tr>
<tr class="memitem:ac5197ae490a155c204cf6f6faddcbf10"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#ac5197ae490a155c204cf6f6faddcbf10">filterMap</a> (TFilterMapFn filterMapFn)</td></tr>
<tr class="memdesc:ac5197ae490a155c204cf6f6faddcbf10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new iterator that filters and maps items from this iterator.  <a href="classCXXIter_1_1IterApi.html#ac5197ae490a155c204cf6f6faddcbf10">More...</a><br /></td></tr>
<tr class="separator:ac5197ae490a155c204cf6f6faddcbf10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf4cbe6073a887100d549f0bea73a90e"><td class="memItemLeft" align="right" valign="top">op::SkipN&lt; TSelf &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#acf4cbe6073a887100d549f0bea73a90e">skip</a> (size_t cnt)</td></tr>
<tr class="memdesc:acf4cbe6073a887100d549f0bea73a90e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an iterator that skips the first <code>cnt</code> elements from this iterator, before it yields the remaining items.  <a href="classCXXIter_1_1IterApi.html#acf4cbe6073a887100d549f0bea73a90e">More...</a><br /></td></tr>
<tr class="separator:acf4cbe6073a887100d549f0bea73a90e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc72090031914ff844c3242fddbd22c2"><td class="memTemplParams" colspan="2">template&lt;std::invocable&lt; const <a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a> &amp; &gt; TSkipPredicate&gt; </td></tr>
<tr class="memitem:abc72090031914ff844c3242fddbd22c2"><td class="memTemplItemLeft" align="right" valign="top">op::SkipWhile&lt; TSelf, TSkipPredicate &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#abc72090031914ff844c3242fddbd22c2">skipWhile</a> (TSkipPredicate skipPredicate)</td></tr>
<tr class="memdesc:abc72090031914ff844c3242fddbd22c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an iterator that skips the first elements of this iterator, for which the given <code>skipPredicate</code> returns <code>true</code>.  <a href="classCXXIter_1_1IterApi.html#abc72090031914ff844c3242fddbd22c2">More...</a><br /></td></tr>
<tr class="separator:abc72090031914ff844c3242fddbd22c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e72f1bebe09215ce8effe156ca38d34"><td class="memItemLeft" align="right" valign="top">op::TakeN&lt; TSelf &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#a3e72f1bebe09215ce8effe156ca38d34">take</a> (size_t cnt)</td></tr>
<tr class="memdesc:a3e72f1bebe09215ce8effe156ca38d34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an iterator that yields at most the first <code>cnt</code> elements from this iterator.  <a href="classCXXIter_1_1IterApi.html#a3e72f1bebe09215ce8effe156ca38d34">More...</a><br /></td></tr>
<tr class="separator:a3e72f1bebe09215ce8effe156ca38d34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab16a10f60f2eddc85f29974d04672ba4"><td class="memTemplParams" colspan="2">template&lt;std::invocable&lt; const <a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a> &amp; &gt; TTakePredicate&gt; <br />
requires std::is_same_v&lt;std::invoke_result_t&lt;TTakePredicate, const <a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a>&amp;&gt;, bool&gt;</td></tr>
<tr class="memitem:ab16a10f60f2eddc85f29974d04672ba4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#ab16a10f60f2eddc85f29974d04672ba4">takeWhile</a> (TTakePredicate takePredicate)</td></tr>
<tr class="memdesc:ab16a10f60f2eddc85f29974d04672ba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an iterator that yields the first elements of this iterator, for which the given <code>takePredicate</code> returns <code>true</code>.  <a href="classCXXIter_1_1IterApi.html#ab16a10f60f2eddc85f29974d04672ba4">More...</a><br /></td></tr>
<tr class="separator:ab16a10f60f2eddc85f29974d04672ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4cf427f53b7c5916727fe253589b817"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#aa4cf427f53b7c5916727fe253589b817">stepBy</a> (size_t stepWidth)</td></tr>
<tr class="memdesc:aa4cf427f53b7c5916727fe253589b817"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an iterator with the requested <code>stepWidth</code> from this iterator.  <a href="classCXXIter_1_1IterApi.html#aa4cf427f53b7c5916727fe253589b817">More...</a><br /></td></tr>
<tr class="separator:aa4cf427f53b7c5916727fe253589b817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a697a84ef397adc29008d87edbc7095fc"><td class="memTemplParams" colspan="2">template&lt;typename TOtherIterator &gt; </td></tr>
<tr class="memitem:a697a84ef397adc29008d87edbc7095fc"><td class="memTemplItemLeft" align="right" valign="top">op::Zipper&lt; TSelf, std::pair, TOtherIterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#a697a84ef397adc29008d87edbc7095fc">zip</a> (TOtherIterator &amp;&amp;otherIterator)</td></tr>
<tr class="memdesc:a697a84ef397adc29008d87edbc7095fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Zips up" two <a class="el" href="namespaceCXXIter.html" title="CXXIter.">CXXIter</a> iterators into a single iterator over pairs from both iterators.  <a href="classCXXIter_1_1IterApi.html#a697a84ef397adc29008d87edbc7095fc">More...</a><br /></td></tr>
<tr class="separator:a697a84ef397adc29008d87edbc7095fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69a33172afd539a6dd763492752139c7"><td class="memTemplParams" colspan="2">template&lt;typename... TOtherIterators&gt; <br />
requires (CXXIterIterator&lt;TOtherIterators&gt; &amp;&amp; ...) &amp;&amp; (!std::disjunction_v&lt; std::is_reference&lt;typename <a class="el" href="structCXXIter_1_1trait_1_1Iterator.html">trait::Iterator</a>&lt;TOtherIterators&gt;<a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">::Item</a>&gt;... &gt; &amp;&amp; !IS_REFERENCE)</td></tr>
<tr class="memitem:a69a33172afd539a6dd763492752139c7"><td class="memTemplItemLeft" align="right" valign="top">op::Zipper&lt; TSelf, std::tuple, TOtherIterators... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#a69a33172afd539a6dd763492752139c7">zipTuple</a> (TOtherIterators &amp;&amp;... otherIterators)</td></tr>
<tr class="memdesc:a69a33172afd539a6dd763492752139c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Zips up" an arbitrary amount of <a class="el" href="namespaceCXXIter.html" title="CXXIter.">CXXIter</a> iterators into a single iterator over <code>std::tuple&lt;&gt;</code> from both iterators.  <a href="classCXXIter_1_1IterApi.html#a69a33172afd539a6dd763492752139c7">More...</a><br /></td></tr>
<tr class="separator:a69a33172afd539a6dd763492752139c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ff8681de8cdfaff25d2d5b04226c983"><td class="memTemplParams" colspan="2">template&lt;typename TOtherIterator &gt; <br />
requires std::is_same_v&lt;<a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a>, typename TOtherIterator::Item&gt;</td></tr>
<tr class="memitem:a1ff8681de8cdfaff25d2d5b04226c983"><td class="memTemplItemLeft" align="right" valign="top">op::Chainer&lt; TSelf, TOtherIterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#a1ff8681de8cdfaff25d2d5b04226c983">chain</a> (TOtherIterator &amp;&amp;otherIterator)</td></tr>
<tr class="memdesc:a1ff8681de8cdfaff25d2d5b04226c983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chains this iterator with the given <code>otherIterator</code>, resulting in a new iterator that first yields the elements of this iterator, and then the ones from the <code>otherIterator</code>.  <a href="classCXXIter_1_1IterApi.html#a1ff8681de8cdfaff25d2d5b04226c983">More...</a><br /></td></tr>
<tr class="separator:a1ff8681de8cdfaff25d2d5b04226c983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa1c741537285e51bec0d2d47da718f1"><td class="memTemplParams" colspan="2">template&lt;typename... TOtherIterators&gt; <br />
requires (CXXIterIterator&lt;TOtherIterators&gt; &amp;&amp; ...) &amp;&amp; (util::are_same_v&lt;<a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a>, typename TOtherIterators::Item...&gt;)</td></tr>
<tr class="memitem:afa1c741537285e51bec0d2d47da718f1"><td class="memTemplItemLeft" align="right" valign="top">op::Alternater&lt; TSelf, TOtherIterators... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#afa1c741537285e51bec0d2d47da718f1">alternate</a> (TOtherIterators &amp;&amp;... otherIterators)</td></tr>
<tr class="memdesc:afa1c741537285e51bec0d2d47da718f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternating the elements of this iterator with the ones from the other given iterator(s).  <a href="classCXXIter_1_1IterApi.html#afa1c741537285e51bec0d2d47da718f1">More...</a><br /></td></tr>
<tr class="separator:afa1c741537285e51bec0d2d47da718f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b19694e4307cbc0387dab5c715e73e2"><td class="memTemplParams" colspan="2">template&lt;typename TOtherIterator &gt; <br />
requires (std::is_same_v&lt;<a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a>, typename TOtherIterator::Item&gt;)</td></tr>
<tr class="memitem:a0b19694e4307cbc0387dab5c715e73e2"><td class="memTemplItemLeft" align="right" valign="top">op::Intersperser&lt; TSelf, TOtherIterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#a0b19694e4307cbc0387dab5c715e73e2">intersperse</a> (TOtherIterator &amp;&amp;otherIterator)</td></tr>
<tr class="memdesc:a0b19694e4307cbc0387dab5c715e73e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw elements from the given <code>otherIterator</code> and use the returned elements as separators between the elements of this iterator.  <a href="classCXXIter_1_1IterApi.html#a0b19694e4307cbc0387dab5c715e73e2">More...</a><br /></td></tr>
<tr class="separator:a0b19694e4307cbc0387dab5c715e73e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa19a261cd49deb306a1558de75af19c4"><td class="memTemplParams" colspan="2">template&lt;std::invocable&lt; const <a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a> &amp; &gt; TGroupIdentifierFn&gt; <br />
requires util::is_hashable&lt;std::invoke_result_t&lt;TGroupIdentifierFn, const <a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a>&amp;&gt;&gt;</td></tr>
<tr class="memitem:aa19a261cd49deb306a1558de75af19c4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#aa19a261cd49deb306a1558de75af19c4">groupBy</a> (TGroupIdentifierFn groupIdentFn)</td></tr>
<tr class="memdesc:aa19a261cd49deb306a1558de75af19c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Groups the elements of this iterator according to the values returned by the given <code>groupidentFn</code>.  <a href="classCXXIter_1_1IterApi.html#aa19a261cd49deb306a1558de75af19c4">More...</a><br /></td></tr>
<tr class="separator:aa19a261cd49deb306a1558de75af19c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff8dd89925c1e49327c408467ebdab22"><td class="memTemplParams" colspan="2">template&lt;bool STABLE, std::invocable&lt; const <a class="el" href="classCXXIter_1_1IterApi.html#a628012452f851b7099d919218e2a5512">ItemOwned</a> &amp;, const <a class="el" href="classCXXIter_1_1IterApi.html#a628012452f851b7099d919218e2a5512">ItemOwned</a> &amp; &gt; TCompareFn&gt; </td></tr>
<tr class="memitem:aff8dd89925c1e49327c408467ebdab22"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#aff8dd89925c1e49327c408467ebdab22">sort</a> (TCompareFn compareFn)</td></tr>
<tr class="memdesc:aff8dd89925c1e49327c408467ebdab22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new iterator that takes the items from this iterator, and passes them on sorted, using the supplied <code>compareFn</code>.  <a href="classCXXIter_1_1IterApi.html#aff8dd89925c1e49327c408467ebdab22">More...</a><br /></td></tr>
<tr class="separator:aff8dd89925c1e49327c408467ebdab22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c752a71a1a7931c711ed6749c62080"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceCXXIter.html#a36594d1d501e0f5fc7d80174fc82e42c">SortOrder</a> ORDER = SortOrder::ASCENDING, bool STABLE = false&gt; <br />
requires requires(const <a class="el" href="classCXXIter_1_1IterApi.html#a628012452f851b7099d919218e2a5512">ItemOwned</a>&amp; a) { { a &lt; a }; { a &gt; a }; }</td></tr>
<tr class="memitem:af8c752a71a1a7931c711ed6749c62080"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#af8c752a71a1a7931c711ed6749c62080">sort</a> ()</td></tr>
<tr class="memdesc:af8c752a71a1a7931c711ed6749c62080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new iterator that takes the items from this iterator, and passes them on sorted.  <a href="classCXXIter_1_1IterApi.html#af8c752a71a1a7931c711ed6749c62080">More...</a><br /></td></tr>
<tr class="separator:af8c752a71a1a7931c711ed6749c62080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcf9678cee596627f5c9712a8efb7518"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceCXXIter.html#a36594d1d501e0f5fc7d80174fc82e42c">SortOrder</a> ORDER = SortOrder::ASCENDING, bool STABLE = false, std::invocable&lt; const <a class="el" href="classCXXIter_1_1IterApi.html#a628012452f851b7099d919218e2a5512">ItemOwned</a> &amp; &gt; TSortValueExtractFn&gt; <br />
requires requires(const std::invoke_result_t&lt;TSortValueExtractFn, const <a class="el" href="classCXXIter_1_1IterApi.html#a628012452f851b7099d919218e2a5512">ItemOwned</a>&amp;&gt;&amp; a) { { a &lt; a }; { a &gt; a }; }</td></tr>
<tr class="memitem:afcf9678cee596627f5c9712a8efb7518"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#afcf9678cee596627f5c9712a8efb7518">sortBy</a> (TSortValueExtractFn sortValueExtractFn)</td></tr>
<tr class="memdesc:afcf9678cee596627f5c9712a8efb7518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new iterator that takes the items from this iterator, and passes them on sorted.  <a href="classCXXIter_1_1IterApi.html#afcf9678cee596627f5c9712a8efb7518">More...</a><br /></td></tr>
<tr class="separator:afcf9678cee596627f5c9712a8efb7518"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;CXXIterIterator TSelf&gt;<br />
class CXXIter::IterApi&lt; TSelf &gt;</div><p >Public Iterator API surface. </p>

<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l00057">57</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a00f3ed5b2201522d327c6a8a92d371c8" name="a00f3ed5b2201522d327c6a8a92d371c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00f3ed5b2201522d327c6a8a92d371c8">&#9670;&nbsp;</a></span>Item</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::Item =  typename <a class="el" href="structCXXIter_1_1trait_1_1Iterator.html#a384416c2080e247759c652b17c9c4575">Iterator::Item</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of the elements of this iterator. (Can be references) </p>

<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l00066">66</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>

</div>
</div>
<a id="a628012452f851b7099d919218e2a5512" name="a628012452f851b7099d919218e2a5512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a628012452f851b7099d919218e2a5512">&#9670;&nbsp;</a></span>ItemOwned</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::ItemOwned =  std::remove_cvref_t&lt;<a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Owned Type of the elements of this iterator. (References removed). </p>

<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l00070">70</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>

</div>
</div>
<a id="a1ca8ef5efb4a7f873cdcb094e1547e52" name="a1ca8ef5efb4a7f873cdcb094e1547e52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ca8ef5efb4a7f873cdcb094e1547e52">&#9670;&nbsp;</a></span>Iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::Iterator =  <a class="el" href="structCXXIter_1_1trait_1_1Iterator.html">trait::Iterator</a>&lt;TSelf&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of the <a class="el" href="structCXXIter_1_1trait_1_1Iterator.html" title="Trait, that is used for the chaining and the operation of iterator pipelines.">trait::Iterator</a> implemenation for this. </p>

<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l00062">62</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae0545d71c1c8f38bd42e712c3a2e1e96" name="ae0545d71c1c8f38bd42e712c3a2e1e96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0545d71c1c8f38bd42e712c3a2e1e96">&#9670;&nbsp;</a></span>~IterApi()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::~<a class="el" href="classCXXIter_1_1IterApi.html">IterApi</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l00078">78</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab41004a90f1d09365840d58c6dbc76e9" name="ab41004a90f1d09365840d58c6dbc76e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab41004a90f1d09365840d58c6dbc76e9">&#9670;&nbsp;</a></span>advanceBy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::advanceBy </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Advance the iterator by n elements. </p>
<p >If possible, this is a O(1) operation. Some iterator pipeline elements make that impossible though. In these cases, the implementation falls back to pulling n elements and dropping them. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The amount of elements to advance the iterator by.</td></tr>
  </table>
  </dd>
</dl>
<p>Usage Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> src = CXXIter::range&lt;float&gt;(1.337f, 2.0f, 0.25f, 5.0f, 42.0f);</div>
<div class="line">   std::optional&lt;float&gt; output = src.next().toStdOptional();</div>
<div class="line"><span class="comment">// output == Some(1.337f);</span></div>
<div class="line">src.advanceBy(2);</div>
<div class="line">output = src.next().toStdOptional();</div>
<div class="line"><span class="comment">// output == Some(5.0f);</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l00197">197</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classCXXIter_1_1IterApi_ab41004a90f1d09365840d58c6dbc76e9_cgraph.svg" width="424" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a27ea52a9390e9127a7fafd760a68fc0c" name="a27ea52a9390e9127a7fafd760a68fc0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27ea52a9390e9127a7fafd760a68fc0c">&#9670;&nbsp;</a></span>all() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::all </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests if all elements of this iterator yield the value <code>true</code> when casted to <code>bool</code>. </p>
<dl class="section note"><dt>Note</dt><dd>This consumes the iterator.</dd></dl>
<p>This is an overload of <a class="el" href="classCXXIter_1_1IterApi.html#a6d6aae5cb3890b2a21bb2d30cd55623d" title="Tests if all elements of this iterator match the given predicateFn.">all(TPredicateFn)</a> for item types that support being casted to <code>bool</code>. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> when all elements of this iterator yielded the value <code>true</code> when casted to a <code>bool</code>, <code>false</code> otherwise.</dd></dl>
<p>Usage Example:</p><ul>
<li>For cases where not all elements of this iterator evaluate to <code>true</code> when casted to <code>bool</code>. <div class="fragment"><div class="line">std::vector&lt;bool&gt; input = { <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span> };</div>
<div class="line"><span class="keywordtype">bool</span> output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input).copied().all();</div>
<div class="line"><span class="comment">// output == false</span></div>
<div class="line"> </div>
<div class="line">std::vector&lt;bool&gt; input = { <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">true</span> };</div>
<div class="line"><span class="keywordtype">bool</span> output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input).copied().all();</div>
<div class="line"><span class="comment">// output == false</span></div>
<div class="line"> </div>
<div class="line">std::vector&lt;bool&gt; input = { <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">true</span> };</div>
<div class="line"><span class="keywordtype">bool</span> output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input).copied().all();</div>
<div class="line"><span class="comment">// output == false</span></div>
<div class="ttc" id="anamespaceCXXIter_html_a488278efdb3aea93ff9fa7583e3c81a8"><div class="ttname"><a href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a></div><div class="ttdeci">SrcMov&lt; std::remove_cvref_t&lt; TContainer &gt; &gt; from(TContainer &amp;&amp;container)</div><div class="ttdoc">Construct a CXXIter move source from the given container.</div><div class="ttdef"><b>Definition:</b> <a href="CXXIter_8h_source.html#l02132">CXXIter.h:2132</a></div></div>
</div><!-- fragment --></li>
<li>For cases where all elements of this iterator evaluate to <code>true</code> when casted to <code>bool</code>. <div class="fragment"><div class="line">std::vector&lt;bool&gt; input = { <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">true</span> };</div>
<div class="line"><span class="keywordtype">bool</span> output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input).copied().all();</div>
<div class="line"><span class="comment">// output == true</span></div>
</div><!-- fragment --> </li>
</ul>

<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l00433">433</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>

</div>
</div>
<a id="a6d6aae5cb3890b2a21bb2d30cd55623d" name="a6d6aae5cb3890b2a21bb2d30cd55623d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d6aae5cb3890b2a21bb2d30cd55623d">&#9670;&nbsp;</a></span>all() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<div class="memtemplate">
template&lt;std::invocable&lt; const <a class="el" href="classCXXIter_1_1IterApi.html#a628012452f851b7099d919218e2a5512">ItemOwned</a> &amp; &gt; TPredicateFn&gt; <br />
requires std::same_as&lt;std::invoke_result_t&lt;TPredicateFn, const <a class="el" href="classCXXIter_1_1IterApi.html#a628012452f851b7099d919218e2a5512">ItemOwned</a>&amp;&gt;, bool&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::all </td>
          <td>(</td>
          <td class="paramtype">TPredicateFn&#160;</td>
          <td class="paramname"><em>predicateFn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests if all elements of this iterator match the given <code>predicateFn</code>. </p>
<dl class="section note"><dt>Note</dt><dd>This consumes the iterator. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicateFn</td><td>Predicate to test all items of this iterator against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> when the given <code>predicateFn</code> returned <code>true</code> for all elements of this iterator, <code>false</code> otherwise.</dd></dl>
<p>Usage Example: (Using the following predicate) </p><div class="fragment"><div class="line"><span class="keyword">auto</span> intAsBoolFn = [](uint32_t item) -&gt; <span class="keywordtype">bool</span> { <span class="keywordflow">return</span> (item != 0); };</div>
</div><!-- fragment --><ul>
<li>For cases where the predicate does not return <code>true</code> for all elements: <div class="fragment"><div class="line">std::vector&lt;uint32_t&gt; input = { 1, 1, 1, 0 };</div>
<div class="line"><span class="keywordtype">bool</span> output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input).copied().all(intAsBoolFn);</div>
<div class="line"><span class="comment">// output == false</span></div>
<div class="line"> </div>
<div class="line">std::vector&lt;uint32_t&gt; input = { 0, 1, 1, 1 };</div>
<div class="line"><span class="keywordtype">bool</span> output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input).copied().all(intAsBoolFn);</div>
<div class="line"><span class="comment">// output == false</span></div>
<div class="line"> </div>
<div class="line">std::vector&lt;uint32_t&gt; input = { 0, 0, 1, 1 };</div>
<div class="line"><span class="keywordtype">bool</span> output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input).copied().all(intAsBoolFn);</div>
<div class="line"><span class="comment">// output == false</span></div>
</div><!-- fragment --></li>
<li>For cases where the predicate does return <code>true</code> for all elements: <div class="fragment"><div class="line">std::vector&lt;uint32_t&gt; input = { 1, 1, 1, 1 };</div>
<div class="line"><span class="keywordtype">bool</span> output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input).copied().all(intAsBoolFn);</div>
<div class="line"><span class="comment">// output == true</span></div>
</div><!-- fragment --> </li>
</ul>

<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l00398">398</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classCXXIter_1_1IterApi_a6d6aae5cb3890b2a21bb2d30cd55623d_cgraph.svg" width="400" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="afa1c741537285e51bec0d2d47da718f1" name="afa1c741537285e51bec0d2d47da718f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa1c741537285e51bec0d2d47da718f1">&#9670;&nbsp;</a></span>alternate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<div class="memtemplate">
template&lt;typename... TOtherIterators&gt; <br />
requires (CXXIterIterator&lt;TOtherIterators&gt; &amp;&amp; ...) &amp;&amp; (util::are_same_v&lt;<a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a>, typename TOtherIterators::Item...&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">op::Alternater&lt; TSelf, TOtherIterators... &gt; <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::alternate </td>
          <td>(</td>
          <td class="paramtype">TOtherIterators &amp;&amp;...&#160;</td>
          <td class="paramname"><em>otherIterators</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alternating the elements of this iterator with the ones from the other given iterator(s). </p>
<p >Everytime an element is polled from the iterator resulting from this call, an element from the current input iterator is forwarded. Then, the current input iterator is switched to the next input. The resulting iterator ends, when the currently active input has no more elements. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">otherIterators</td><td>An arbitrary amount of iterators to alternate the elements of this iterator with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new iterator that interweaves the elements from this iterator and all the given iterators in order.</dd></dl>
<p>Usage Example: </p><div class="fragment"><div class="line">   std::vector&lt;int&gt; input1 = {1, 4, 7};</div>
<div class="line">   std::vector&lt;int&gt; input2 = {2, 5};</div>
<div class="line">   std::vector&lt;int&gt; input3 = {3, 6, 9};</div>
<div class="line">   std::vector&lt;int&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input1)</div>
<div class="line">       .alternate(<a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input2), <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input3))</div>
<div class="line">       .collect&lt;std::vector&gt;();</div>
<div class="line"><span class="comment">// output == {1, 2, 3, 4, 5, 6, 7}</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l01922">1922</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>

</div>
</div>
<a id="a4f621d583ff137b6537eff24d96b2c18" name="a4f621d583ff137b6537eff24d96b2c18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f621d583ff137b6537eff24d96b2c18">&#9670;&nbsp;</a></span>any() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::any </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests if any of the elements of this iterator yield the value <code>true</code> when casted to <code>bool</code>. </p>
<dl class="section note"><dt>Note</dt><dd>This consumes the iterator.</dd></dl>
<p>This is an overload of <a class="el" href="classCXXIter_1_1IterApi.html#a233794e7bcf62f21de8f66cff22750b0" title="Tests if any of the elements of this iterator match the given predicateFn.">any(TPredicateFn)</a> for item types that support being casted to <code>bool</code>. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> when any of the elements of this iterator yielded the value <code>true</code> when casted to a <code>bool</code>, <code>false</code> otherwise.</dd></dl>
<p>Usage Example:</p><ul>
<li>For cases where none of the elements yields the value <code>true</code> when casted to <code>bool</code>. <div class="fragment"><div class="line">std::vector&lt;bool&gt; input = { <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span> };</div>
<div class="line"><span class="keywordtype">bool</span> output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input).copied().any();</div>
<div class="line"><span class="comment">// output == false</span></div>
</div><!-- fragment --></li>
<li>For cases where any of the elements yields the value <code>true</code> when casted to <code>bool</code>. <div class="fragment"><div class="line">std::vector&lt;bool&gt; input = { <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">true</span> };</div>
<div class="line"><span class="keywordtype">bool</span> output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input).copied().any();</div>
<div class="line"><span class="comment">// output == true</span></div>
<div class="line"> </div>
<div class="line">std::vector&lt;bool&gt; input = { <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span> };</div>
<div class="line"><span class="keywordtype">bool</span> output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input).copied().any();</div>
<div class="line"><span class="comment">// output == true</span></div>
<div class="line"> </div>
<div class="line">std::vector&lt;bool&gt; input = { <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">true</span> };</div>
<div class="line"><span class="keywordtype">bool</span> output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input).copied().any();</div>
<div class="line"><span class="comment">// output == true</span></div>
</div><!-- fragment --> </li>
</ul>

<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l00509">509</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>

</div>
</div>
<a id="a233794e7bcf62f21de8f66cff22750b0" name="a233794e7bcf62f21de8f66cff22750b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a233794e7bcf62f21de8f66cff22750b0">&#9670;&nbsp;</a></span>any() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<div class="memtemplate">
template&lt;std::invocable&lt; const <a class="el" href="classCXXIter_1_1IterApi.html#a628012452f851b7099d919218e2a5512">ItemOwned</a> &amp; &gt; TPredicateFn&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::any </td>
          <td>(</td>
          <td class="paramtype">TPredicateFn&#160;</td>
          <td class="paramname"><em>predicateFn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests if any of the elements of this iterator match the given <code>predicateFn</code>. </p>
<dl class="section note"><dt>Note</dt><dd>This consumes the iterator. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicateFn</td><td>Predicate to test all items of this iterator against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> when the given <code>predicateFn</code> returned <code>true</code> for any of the elements of this iterator, <code>false</code> otherwise.</dd></dl>
<p>Usage Example: (Using the following predicate) </p><div class="fragment"><div class="line"><span class="keyword">auto</span> intAsBoolFn = [](uint32_t item) -&gt; <span class="keywordtype">bool</span> { <span class="keywordflow">return</span> (item != 0); };</div>
</div><!-- fragment --><ul>
<li>For the case where the <code>predicateFn</code> returns <code>false</code> for all elements: <div class="fragment"><div class="line">std::vector&lt;uint32_t&gt; input = { 0, 0, 0, 0 };</div>
<div class="line"><span class="keywordtype">bool</span> output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input).copied().any(intAsBoolFn);</div>
<div class="line"><span class="comment">// output == false</span></div>
</div><!-- fragment --></li>
<li>For the case where the <code>predicateFn</code> returns <code>true</code> for any of the elements: <div class="fragment"><div class="line">std::vector&lt;uint32_t&gt; input = { 0, 1, 1, 1 };</div>
<div class="line"><span class="keywordtype">bool</span> output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input).copied().any(intAsBoolFn);</div>
<div class="line"><span class="comment">// output == true</span></div>
<div class="line"> </div>
<div class="line">std::vector&lt;uint32_t&gt; input = { 0, 0, 0, 1 };</div>
<div class="line"><span class="keywordtype">bool</span> output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input).copied().any(intAsBoolFn);</div>
<div class="line"><span class="comment">// output == true</span></div>
<div class="line"> </div>
<div class="line">std::vector&lt;uint32_t&gt; input = { 1, 1, 1, 1 };</div>
<div class="line"><span class="keywordtype">bool</span> output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input).copied().any(intAsBoolFn);</div>
<div class="line"><span class="comment">// output == true</span></div>
</div><!-- fragment --> </li>
</ul>

<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l00474">474</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classCXXIter_1_1IterApi_a233794e7bcf62f21de8f66cff22750b0_cgraph.svg" width="374" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="aaa8bf456c009689898f75879d1691120" name="aaa8bf456c009689898f75879d1691120"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa8bf456c009689898f75879d1691120">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCXXIter_1_1IterApi_1_1iterator.html">iterator</a> <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classCXXIter_1_1IterApi.html#aaa8bf456c009689898f75879d1691120" title="begin() method, part of C++&#39;s iterator interface">begin()</a> method, part of C++'s iterator interface </p>
<dl class="section return"><dt>Returns</dt><dd>C++ interface on top of this iterator pipeline. </dd></dl>

<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l00115">115</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classCXXIter_1_1IterApi_aaa8bf456c009689898f75879d1691120_cgraph.svg" width="384" height="60"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a4d7e8944accd23e1175e685d34010306" name="a4d7e8944accd23e1175e685d34010306"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d7e8944accd23e1175e685d34010306">&#9670;&nbsp;</a></span>cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<div class="memtemplate">
template&lt;typename TItemOutput &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">op::Caster&lt; TSelf, TItemOutput &gt; <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::cast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a new iterator that casts the elements of this iterator to the type requested by <code>TItemOutput</code>. </p>
<p >This iterator applies the requested type cast to <code>TItemOutput</code> using <code>static_cast&lt;&gt;</code>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TItemOutput</td><td>Type to cast the elements of this iterator to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new iterator that casts all elements from this iterator to the requested type <code>TItemOutput</code>.</dd></dl>
<p>Usage Example: </p><div class="fragment"><div class="line">std::vector&lt;float&gt; input = {1.35, 56.123};</div>
<div class="line">std::vector&lt;double&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input)</div>
<div class="line">        .cast&lt;<span class="keywordtype">double</span>&gt;()</div>
<div class="line">        .collect&lt;std::vector&gt;();</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l01260">1260</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>

</div>
</div>
<a id="a1ff8681de8cdfaff25d2d5b04226c983" name="a1ff8681de8cdfaff25d2d5b04226c983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ff8681de8cdfaff25d2d5b04226c983">&#9670;&nbsp;</a></span>chain()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<div class="memtemplate">
template&lt;typename TOtherIterator &gt; <br />
requires std::is_same_v&lt;<a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a>, typename TOtherIterator::Item&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">op::Chainer&lt; TSelf, TOtherIterator &gt; <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::chain </td>
          <td>(</td>
          <td class="paramtype">TOtherIterator &amp;&amp;&#160;</td>
          <td class="paramname"><em>otherIterator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Chains this iterator with the given <code>otherIterator</code>, resulting in a new iterator that first yields the elements of this iterator, and then the ones from the <code>otherIterator</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">otherIterator</td><td>Other iterator whose elements should be "appended" to the elements of this iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New iterator that consists of a chain of this iterator with the given <code>otherIterator</code>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>For this to work, the elements' types of this iterator and the given <code>otherIterator</code> have to be identical.</dd></dl>
<p>Usage Example: </p><div class="fragment"><div class="line">   std::vector&lt;std::string&gt; input1 = {<span class="stringliteral">&quot;1337&quot;</span>, <span class="stringliteral">&quot;42&quot;</span>};</div>
<div class="line">   std::vector&lt;std::string&gt; input2 = {<span class="stringliteral">&quot;31337&quot;</span>, <span class="stringliteral">&quot;64&quot;</span>};</div>
<div class="line">   std::vector&lt;std::string&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input1).copied()</div>
<div class="line">           .chain(<a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input2).<a class="code hl_function" href="classCXXIter_1_1IterApi.html#a116afb3640cb245742403c86fded359f">copied</a>())</div>
<div class="line">           .collect&lt;std::vector&gt;();</div>
<div class="line"><span class="comment">// output == {&quot;1337&quot;, &quot;42&quot;, &quot;31337&quot;, &quot;64&quot;}</span></div>
<div class="ttc" id="aclassCXXIter_1_1IterApi_html_a116afb3640cb245742403c86fded359f"><div class="ttname"><a href="classCXXIter_1_1IterApi.html#a116afb3640cb245742403c86fded359f">CXXIter::IterApi::copied</a></div><div class="ttdeci">auto copied()</div><div class="ttdoc">Constructs a new iterator that copies the elements of this iterator.</div><div class="ttdef"><b>Definition:</b> <a href="CXXIter_8h_source.html#l01279">CXXIter.h:1279</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l01896">1896</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>

</div>
</div>
<a id="ad4a7ab60181e939f57eb56373c5a2bbe" name="ad4a7ab60181e939f57eb56373c5a2bbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4a7ab60181e939f57eb56373c5a2bbe">&#9670;&nbsp;</a></span>chunked()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<div class="memtemplate">
template&lt;const size_t CHUNK_SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">op::Chunked&lt; TSelf, CHUNK_SIZE &gt; <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::chunked </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new iterator that collects elements from this iterator in chunks of size up to <code>CHUNK_SIZE</code>, which then constitue the elements of the new iterator. </p>
<p >Chunks are of up to <code>CHUNK_SIZE</code> elements in size. If the amount of items in the iterator are not dividable by the requested <code>CHUNK_SIZE</code> the last chunk will be smaller. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CHUNK_SIZE</td><td>Amount of elements from this iterator, that get collected to one chunk. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New iterator that contains chunks of up to the requested size, containing elements from this iterator as elements.</dd></dl>
<p>Usage Example:</p><ul>
<li>If the amount of elements of the input can be evenly divided up into the requested <code>CHUNK_SIZE</code> : <div class="fragment"><div class="line">std::vector&lt;size_t&gt; input = {1337, 42, 512, 31337, 69, 5, 1, 2, 3};</div>
<div class="line"><span class="keyword">auto</span> output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input)</div>
<div class="line">        .copied()</div>
<div class="line">        .chunked&lt;3&gt;()</div>
<div class="line">        .collect&lt;std::vector&gt;();</div>
<div class="line"><span class="comment">// output == { {1337, 42, 512}, {31337, 69, 5}, {1, 2, 3} }</span></div>
</div><!-- fragment --></li>
<li>If the amount of elements of the input can <b>not</b> be evenly divided up into the requested <code>CHUNK_SIZE</code> : <div class="fragment"><div class="line">std::vector&lt;size_t&gt; input = {1337, 42, 512, 31337, 69, 5, 1, 2};</div>
<div class="line"><span class="keyword">auto</span> output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input)</div>
<div class="line">        .copied()</div>
<div class="line">        .chunked&lt;3&gt;()</div>
<div class="line">        .collect&lt;std::vector&gt;();</div>
<div class="line"><span class="comment">// output == { {1337, 42, 512}, {31337, 69, 5}, {1, 2} }</span></div>
</div><!-- fragment --> </li>
</ul>

<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l01455">1455</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>

</div>
</div>
<a id="aa100f6d93caf6b3537535df3a4a81e32" name="aa100f6d93caf6b3537535df3a4a81e32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa100f6d93caf6b3537535df3a4a81e32">&#9670;&nbsp;</a></span>chunkedExact()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<div class="memtemplate">
template&lt;const size_t CHUNK_SIZE, const size_t STEP_SIZE = CHUNK_SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">op::ChunkedExact&lt; TSelf, CHUNK_SIZE, STEP_SIZE &gt; <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::chunkedExact </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new iterator that collects elements from this iterator in exact-sized chunks of <code>CHUNK_SIZE</code>, which then constitue the elements of the new iterator. </p>
<p >A chunk is only committed in the new iterator, after it was filled completely. That means, that if the amount of elements in this iterator do not evenly divide up to <code>CHUNK_SIZE</code> sized chunks, the last couple of elements that fail to fill a complete chunk will be dropped. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CHUNK_SIZE</td><td>Amount of elements from this iterator, that get collected to one chunk. </td></tr>
    <tr><td class="paramname">STEP_SIZE</td><td>Controls the step-size between chunks. Per default, this is set to the same as <code>CHUNK_SIZE</code>, so the produced chunks are directly adjacent. If this is set to a value smaler than <code>CHUNK_SIZE</code>, the generated chunks will overlap. If this is set to a value higher than <code>CHUNK_SIZE</code>, the generated chunks will have gaps in between (those items are dropped). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New iterator that contains exact-sized (<code>CHUNK_SIZE</code>) chunks of elements from this iterator as elements.</dd></dl>
<p>Usage Example:</p><ul>
<li>If the amount of elements of the input can be evenly divided up into the requested <code>CHUNK_SIZE</code> : <div class="fragment"><div class="line">std::vector&lt;size_t&gt; input = {1337, 42, 512, 31337, 69, 5, 1, 2, 3};</div>
<div class="line"><span class="keyword">auto</span> output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input)</div>
<div class="line">        .copied()</div>
<div class="line">        .chunkedExact&lt;3&gt;()</div>
<div class="line">        .collect&lt;std::vector&gt;();</div>
<div class="line"><span class="comment">// output == { {1337, 42, 512}, {31337, 69, 5}, {1, 2, 3} }</span></div>
</div><!-- fragment --></li>
<li>If the amount of elements of the input can <b>not</b> be evenly divided up into the requested <code>CHUNK_SIZE</code> : <div class="fragment"><div class="line">std::vector&lt;size_t&gt; input = {1337, 42, 512, 31337, 69, 5, 1, 2};</div>
<div class="line"><span class="keyword">auto</span> output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input)</div>
<div class="line">        .copied()</div>
<div class="line">        .chunkedExact&lt;3&gt;()</div>
<div class="line">        .collect&lt;std::vector&gt;();</div>
<div class="line"><span class="comment">// output == { {1337, 42, 512}, {31337, 69, 5} }</span></div>
</div><!-- fragment --></li>
<li>Overlapping chunks (STEP_SIZE &lt; CHUNK_SIZE): <div class="fragment"><div class="line">std::vector&lt;size_t&gt; input = {1337, 42, 512, 31337, 69, 5};</div>
<div class="line"><span class="keyword">auto</span> output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input)</div>
<div class="line">        .copied()</div>
<div class="line">        .chunkedExact&lt;3, 1&gt;()</div>
<div class="line">        .collect&lt;std::vector&gt;();</div>
<div class="line"><span class="comment">// output == { {1337, 42, 512}, {42, 512, 31337}, {512, 31337, 69}, {31337, 69, 5} }</span></div>
</div><!-- fragment --></li>
<li>Gapped Chunks (STEP_SIZE &gt; CHUNK_SIZE): <div class="fragment"><div class="line">std::vector&lt;size_t&gt; input = {1337, 42, 512, 31337, 69, 5, 1};</div>
<div class="line"><span class="keyword">auto</span> output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input)</div>
<div class="line">        .copied()</div>
<div class="line">        .chunkedExact&lt;3, 4&gt;()</div>
<div class="line">        .collect&lt;std::vector&gt;();</div>
<div class="line"><span class="comment">// output == { {1337, 42, 512}, {69, 5, 1} }</span></div>
</div><!-- fragment --> </li>
</ul>

<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l01510">1510</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>

</div>
</div>
<a id="a294c5e7bc59f4e4c5d7e40b96dff3a89" name="a294c5e7bc59f4e4c5d7e40b96dff3a89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a294c5e7bc59f4e4c5d7e40b96dff3a89">&#9670;&nbsp;</a></span>collect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<div class="memtemplate">
template&lt;template&lt; typename... &gt; typename TTargetContainer, typename... TTargetContainerArgs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::collect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Consumer that collects all elements from this iterator in a new container of type <code>TTargetContainer</code>. </p>
<dl class="section note"><dt>Note</dt><dd>This consumes the iterator. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TTargetContainer</td><td>Type-Template for the target container that the elements from this iterator should be collected into. The first template parameter of this Type-Template has to take the type of the elements. </td></tr>
    <tr><td class="paramname">TTargetContainerArgs...</td><td>Optional additional type attributes to pass on to the target container. These are appended to the item value type, which is automatically supplied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An instance of <code>TTargetContainer</code> with all the elements of this iterator collected into.</dd></dl>
<p>Usage Example: </p><div class="fragment"><div class="line">std::vector&lt;std::string&gt; input = {<span class="stringliteral">&quot;1337&quot;</span>, <span class="stringliteral">&quot;42&quot;</span>, <span class="stringliteral">&quot;64&quot;</span>};</div>
<div class="line">std::vector&lt;std::string&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input)</div>
<div class="line">    .collect&lt;std::vector&gt;();</div>
</div><!-- fragment --><p >With Additional container type parameters: </p><div class="fragment"><div class="line">std::vector&lt;std::string&gt; input = {<span class="stringliteral">&quot;1337&quot;</span>, <span class="stringliteral">&quot;42&quot;</span>, <span class="stringliteral">&quot;64&quot;</span>};</div>
<div class="line">std::vector&lt;std::string, std::allocator&lt;std::string&gt;&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input)</div>
<div class="line">    .collect&lt;std::vector, std::allocator&lt;std::string&gt;&gt;();</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l00275">275</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>

</div>
</div>
<a id="af624739bd9e8e235500273f5a9465544" name="af624739bd9e8e235500273f5a9465544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af624739bd9e8e235500273f5a9465544">&#9670;&nbsp;</a></span>collect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<div class="memtemplate">
template&lt;typename TTargetContainer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TTargetContainer <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::collect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Consumer that collects all elements from this iterator in a new container of type <code>TTargetContainer</code>. </p>
<dl class="section note"><dt>Note</dt><dd>This consumes the iterator. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TTargetContainer</td><td>Fully qualified type of the target container to collect the items of this iterator into. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An instance of <code>TTargetContainer</code> with all the elements of this iterator collected into.</dd></dl>
<p>Usage Example:</p><ul>
<li>std::vector&lt;std::string&gt; <div class="fragment"><div class="line">std::vector&lt;std::string&gt; input = {<span class="stringliteral">&quot;1337&quot;</span>, <span class="stringliteral">&quot;42&quot;</span>, <span class="stringliteral">&quot;64&quot;</span>};</div>
<div class="line">std::vector&lt;std::string&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input)</div>
<div class="line">    .collect&lt;std::vector&lt;std::string&gt;&gt;();</div>
</div><!-- fragment --></li>
<li>std::vector&lt;std::string&gt; with explicitly defined allocator <div class="fragment"><div class="line">std::vector&lt;std::string&gt; input = {<span class="stringliteral">&quot;1337&quot;</span>, <span class="stringliteral">&quot;42&quot;</span>, <span class="stringliteral">&quot;64&quot;</span>};</div>
<div class="line">std::vector&lt;std::string, std::allocator&lt;std::string&gt;&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input)</div>
<div class="line">    .collect&lt;std::vector&lt;std::string, std::allocator&lt;std::string&gt;&gt;&gt;();</div>
</div><!-- fragment --></li>
<li>std::array&lt;std::string, 3&gt; <div class="fragment"><div class="line">std::vector&lt;std::string&gt; input = {<span class="stringliteral">&quot;1337&quot;</span>, <span class="stringliteral">&quot;42&quot;</span>, <span class="stringliteral">&quot;64&quot;</span>};</div>
<div class="line">std::array&lt;std::string, 3&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input)</div>
<div class="line">    .collect&lt;std::array&lt;std::string, 3&gt;&gt;();</div>
</div><!-- fragment --> </li>
</ul>

<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l00308">308</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classCXXIter_1_1IterApi_af624739bd9e8e235500273f5a9465544_cgraph.svg" width="431" height="60"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ab9f60e619bcb3f2f5728605e5738854c" name="ab9f60e619bcb3f2f5728605e5738854c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9f60e619bcb3f2f5728605e5738854c">&#9670;&nbsp;</a></span>collectInto()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<div class="memtemplate">
template&lt;typename TTargetContainer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::collectInto </td>
          <td>(</td>
          <td class="paramtype">TTargetContainer &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Consumer that collects all elements from this iterator into the given <code>container</code>. </p>
<dl class="section note"><dt>Note</dt><dd>This consumes the iterator. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>to collect this iterator's elements into.</td></tr>
  </table>
  </dd>
</dl>
<p>Before appending this iterator's elements to the elements already present in the given <code>container</code>, the collector tries to resize the <code>container</code> to its current size + this iterator's expected amount of items.</p>
<p >Usage Example: </p><div class="fragment"><div class="line">   std::vector&lt;std::string&gt; input = {<span class="stringliteral">&quot;1337&quot;</span>, <span class="stringliteral">&quot;42&quot;</span>, <span class="stringliteral">&quot;64&quot;</span>};</div>
<div class="line">   std::vector&lt;std::string&gt; output = {<span class="stringliteral">&quot;prevElement&quot;</span>};</div>
<div class="line"><a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input).collectInto(output);</div>
<div class="line"><span class="comment">// output == {&quot;prevElement&quot;, &quot;1337&quot;, &quot;42&quot;, &quot;64&quot;}</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l00331">331</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classCXXIter_1_1IterApi_ab9f60e619bcb3f2f5728605e5738854c_cgraph.svg" width="210" height="60"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a116afb3640cb245742403c86fded359f" name="a116afb3640cb245742403c86fded359f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a116afb3640cb245742403c86fded359f">&#9670;&nbsp;</a></span>copied()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::copied </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a new iterator that copies the elements of this iterator. </p>
<p >This function essentially converts an iterator that is passing elements by reference, to an iterator that is passing elements by value midway. </p><dl class="section return"><dt>Returns</dt><dd>A new iterator that is passing copies of the original input elements by value.</dd></dl>
<p>Usage Example: </p><div class="fragment"><div class="line">std::vector&lt;std::string&gt; input = {<span class="stringliteral">&quot;inputString1&quot;</span>, <span class="stringliteral">&quot;inputString2&quot;</span>};</div>
<div class="line">std::vector&lt;std::string&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input)</div>
<div class="line">    .copied() <span class="comment">// clone values, now working with owned copies instead of references to input</span></div>
<div class="line">    .modify([](std::string&amp; item) { item[item.size() - 1] += 1; }) <span class="comment">// modify copies, input untouched</span></div>
<div class="line">    .collect&lt;std::vector&gt;();</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l01279">1279</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classCXXIter_1_1IterApi_a116afb3640cb245742403c86fded359f_cgraph.svg" width="391" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a418901ce726860a7a91bffbc210c1815" name="a418901ce726860a7a91bffbc210c1815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a418901ce726860a7a91bffbc210c1815">&#9670;&nbsp;</a></span>count() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Consumer that counts the elements in this iterator. </p>
<dl class="section note"><dt>Note</dt><dd>This consumes the iterator. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The amount of elements in this iterator</dd></dl>
<p>Usage Example: </p><div class="fragment"><div class="line">std::vector&lt;int&gt; input = {42, 1337, 52};</div>
<div class="line"><span class="keywordtype">size_t</span> output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input).count();</div>
<div class="line"><span class="comment">// output == 3</span></div>
<div class="line">std::vector&lt;int&gt; input2 = {};</div>
<div class="line"><span class="keywordtype">size_t</span> output2 = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input2).count();</div>
<div class="line"><span class="comment">// output == 0</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l00623">623</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="classCXXIter_1_1IterApi_a418901ce726860a7a91bffbc210c1815_cgraph.svg" width="100%" height="300"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>

</div>
</div>
<a id="afc37b3e2bc9c3417d29ff713e27111e1" name="afc37b3e2bc9c3417d29ff713e27111e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc37b3e2bc9c3417d29ff713e27111e1">&#9670;&nbsp;</a></span>count() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCXXIter_1_1IterApi.html#a628012452f851b7099d919218e2a5512">ItemOwned</a> &amp;&#160;</td>
          <td class="paramname"><em>countItem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Consumer that counts the occurences of <code>countItem</code> within this iterator. </p>
<dl class="section note"><dt>Note</dt><dd>This consumes the iterator. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">countItem</td><td>Item for which to count the amount of occurences within this iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of occurences of <code>countItem</code> within this iterator.</dd></dl>
<p>Usage Example: </p><div class="fragment"><div class="line">std::vector&lt;int&gt; input = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};</div>
<div class="line"><span class="keywordtype">size_t</span> output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input)</div>
<div class="line">        .map([](<span class="keywordtype">int</span> item) { <span class="keywordflow">return</span> (item % 2 == 0); })</div>
<div class="line">        .<a class="code hl_function" href="classCXXIter_1_1IterApi.html#a418901ce726860a7a91bffbc210c1815">count</a>(<span class="keyword">true</span>);</div>
<div class="line"><span class="comment">// output == 5</span></div>
<div class="ttc" id="aclassCXXIter_1_1IterApi_html_a418901ce726860a7a91bffbc210c1815"><div class="ttname"><a href="classCXXIter_1_1IterApi.html#a418901ce726860a7a91bffbc210c1815">CXXIter::IterApi::count</a></div><div class="ttdeci">size_t count()</div><div class="ttdoc">Consumer that counts the elements in this iterator.</div><div class="ttdef"><b>Definition:</b> <a href="CXXIter_8h_source.html#l00623">CXXIter.h:623</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l00665">665</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>

</div>
</div>
<a id="abfd58d36cbf83360cd7a6959971e2ef6" name="abfd58d36cbf83360cd7a6959971e2ef6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfd58d36cbf83360cd7a6959971e2ef6">&#9670;&nbsp;</a></span>count() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<div class="memtemplate">
template&lt;std::invocable&lt; const <a class="el" href="classCXXIter_1_1IterApi.html#a628012452f851b7099d919218e2a5512">ItemOwned</a> &amp; &gt; TPredicateFn&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::count </td>
          <td>(</td>
          <td class="paramtype">TPredicateFn&#160;</td>
          <td class="paramname"><em>predicateFn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Consumer that counts the elements in this iterator, for which the given <code>predicateFn</code> returns <code>true</code>. </p>
<dl class="section note"><dt>Note</dt><dd>This consumes the iterator. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicateFn</td><td>Predicate that is run for each element of this iterator, to determine whether it should contribute to the resulting count. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The amount of elements in this iterator for which the given <code>predicateFn</code> returned <code>true</code>.</dd></dl>
<p>Usage Example: </p><div class="fragment"><div class="line">    std::vector&lt;int&gt; input = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};</div>
<div class="line">    <span class="keywordtype">size_t</span> output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input)</div>
<div class="line">            .count([](<span class="keywordtype">int</span> item){ <span class="keywordflow">return</span> (item % 2 == 0); });</div>
<div class="line"><span class="comment">// output == 5</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l00644">644</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="classCXXIter_1_1IterApi_abfd58d36cbf83360cd7a6959971e2ef6_cgraph.svg" width="100%" height="300"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>

</div>
</div>
<a id="abac1131fb2734cfae22b38099740627a" name="abac1131fb2734cfae22b38099740627a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abac1131fb2734cfae22b38099740627a">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCXXIter_1_1IterApi_1_1iterator.html">iterator</a> <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classCXXIter_1_1IterApi.html#abac1131fb2734cfae22b38099740627a" title="end() method, part of C++&#39;s iterator interface">end()</a> method, part of C++'s iterator interface </p>
<dl class="section return"><dt>Returns</dt><dd>C++ interface on top of this iterator pipeline. </dd></dl>

<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l00121">121</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>

</div>
</div>
<a id="a6fe973bcef3669050b734c6c0c0481bb" name="a6fe973bcef3669050b734c6c0c0481bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fe973bcef3669050b734c6c0c0481bb">&#9670;&nbsp;</a></span>filter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<div class="memtemplate">
template&lt;std::invocable&lt; const <a class="el" href="classCXXIter_1_1IterApi.html#a628012452f851b7099d919218e2a5512">ItemOwned</a> &amp; &gt; TFilterFn&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">op::Filter&lt; TSelf, TFilterFn &gt; <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::filter </td>
          <td>(</td>
          <td class="paramtype">TFilterFn&#160;</td>
          <td class="paramname"><em>filterFn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a new iterator that only contains the elements from this iterator, for which the given <code>filterFn</code> returned <code>true</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filterFn</td><td>Function that decides which element of this iterator to yield in the newly created iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator that only returns the elements for which the <code>filterFn</code> returns <code>true</code>.</dd></dl>
<p>Usage Example: </p><div class="fragment"><div class="line">std::vector&lt;int&gt; input = {1, 2, 3, 4, 5, 6, 7, 8};</div>
<div class="line">std::vector&lt;int&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input)</div>
<div class="line">    .filter([](<span class="keywordtype">int</span> item) { <span class="keywordflow">return</span> (item % 2) == 0; })</div>
<div class="line">    .collect&lt;std::vector&gt;();</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l01354">1354</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>

</div>
</div>
<a id="ac5197ae490a155c204cf6f6faddcbf10" name="ac5197ae490a155c204cf6f6faddcbf10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5197ae490a155c204cf6f6faddcbf10">&#9670;&nbsp;</a></span>filterMap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<div class="memtemplate">
template&lt;std::invocable&lt; <a class="el" href="classCXXIter_1_1IterApi.html#a628012452f851b7099d919218e2a5512">ItemOwned</a> &amp;&amp; &gt; TFilterMapFn&gt; <br />
requires util::is_optional&lt;std::invoke_result_t&lt;TFilterMapFn, <a class="el" href="classCXXIter_1_1IterApi.html#a628012452f851b7099d919218e2a5512">ItemOwned</a>&amp;&amp;&gt;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::filterMap </td>
          <td>(</td>
          <td class="paramtype">TFilterMapFn&#160;</td>
          <td class="paramname"><em>filterMapFn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new iterator that filters and maps items from this iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filterMapFn</td><td>Function that maps the incomming items to an optional mapped value. If it returns an empty <code>std::optional&lt;&gt;</code> the element is filtered. If it returns an <code>std::optional&lt;&gt;</code> with a value, that item is yielded from the resulting iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator that yields only the items for which the given <code>filterMapFn</code> returned a mapped value.</dd></dl>
<p>Usage Example: </p><div class="fragment"><div class="line">std::vector&lt;int&gt; input = {1, 2, 3, 4, 5, 6, 7, 8};</div>
<div class="line">std::vector&lt;int&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input)</div>
<div class="line">    .filterMap([](<span class="keywordtype">int</span> item) -&gt; std::optional&lt;int&gt; {</div>
<div class="line">        <span class="keywordflow">if</span>(item % 2 == 0) { <span class="keywordflow">return</span> (item + 3); }</div>
<div class="line">        <span class="keywordflow">return</span> {};</div>
<div class="line">    })</div>
<div class="line">    .collect&lt;std::vector&gt;();</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l01705">1705</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>

</div>
</div>
<a id="ab44325cb6ee35f352ca90c33db720644" name="ab44325cb6ee35f352ca90c33db720644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab44325cb6ee35f352ca90c33db720644">&#9670;&nbsp;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<div class="memtemplate">
template&lt;std::invocable&lt; const <a class="el" href="classCXXIter_1_1IterApi.html#a628012452f851b7099d919218e2a5512">ItemOwned</a> &amp; &gt; TFindFn&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCXXIter_1_1IterValue.html">IterValue</a>&lt; <a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a> &gt; <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::find </td>
          <td>(</td>
          <td class="paramtype">TFindFn&#160;</td>
          <td class="paramname"><em>findFn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches for an element of this iterator, that satisfies the given <code>findFn</code> predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">findFn</td><td>Predicate used to search for an element in this iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classCXXIter_1_1IterValue.html" title="Container that is used to pass elements through CXXIter&#39;s iterator pipelines.">CXXIter::IterValue</a> containing the first element, for which the <code>findFn</code> predicate returned <code>true</code> (if any), otherwise empty.</dd></dl>
<p>Usage Example:</p><ul>
<li>When item is found in the iterator: <div class="fragment"><div class="line">std::vector&lt;std::string&gt; input = {<span class="stringliteral">&quot;42&quot;</span>, <span class="stringliteral">&quot;1337&quot;</span>, <span class="stringliteral">&quot;52&quot;</span>};</div>
<div class="line"><a class="code hl_class" href="classCXXIter_1_1IterValue.html">CXXIter::IterValue&lt;std::string&amp;&gt;</a> output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input)</div>
<div class="line">        .find([](<span class="keyword">const</span> std::string&amp; item) {</div>
<div class="line">            <span class="keywordflow">return</span> item.size() == 4;</div>
<div class="line">        });</div>
<div class="line"><span class="comment">// output == Some(&quot;1337&quot;&amp;)</span></div>
<div class="ttc" id="aclassCXXIter_1_1IterValue_html"><div class="ttname"><a href="classCXXIter_1_1IterValue.html">CXXIter::IterValue</a></div><div class="ttdoc">Container that is used to pass elements through CXXIter's iterator pipelines.</div><div class="ttdef"><b>Definition:</b> <a href="IterValue_8h_source.html#l00019">IterValue.h:19</a></div></div>
</div><!-- fragment --></li>
<li>When item is not found in the iterator: <div class="fragment"><div class="line">std::vector&lt;std::string&gt; input = {<span class="stringliteral">&quot;42&quot;</span>, <span class="stringliteral">&quot;1337&quot;</span>, <span class="stringliteral">&quot;52&quot;</span>};</div>
<div class="line"><a class="code hl_class" href="classCXXIter_1_1IterValue.html">CXXIter::IterValue&lt;std::string&amp;&gt;</a> output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input)</div>
<div class="line">        .find([](<span class="keyword">const</span> std::string&amp; item) {</div>
<div class="line">            <span class="keywordflow">return</span> item.size() == 3;</div>
<div class="line">        });</div>
<div class="line"><span class="comment">// output == None</span></div>
</div><!-- fragment --> </li>
</ul>

<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l00604">604</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classCXXIter_1_1IterApi_ab44325cb6ee35f352ca90c33db720644_cgraph.svg" width="374" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a8842d23b1b30accf123e096fb7aae099" name="a8842d23b1b30accf123e096fb7aae099"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8842d23b1b30accf123e096fb7aae099">&#9670;&nbsp;</a></span>findIdx() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; size_t &gt; <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::findIdx </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCXXIter_1_1IterApi.html#a628012452f851b7099d919218e2a5512">ItemOwned</a> &amp;&#160;</td>
          <td class="paramname"><em>searchItem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search for the given <code>searchItem</code> within the items of this iterator, and return the index of the first item from the iterator that is equal to the given <code>searchItem</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">searchItem</td><td>Item to search for in the iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index of the given <code>searchItem</code> in the iterator, if found.</dd></dl>
<p>Usage Example:</p><ul>
<li>When item is found in the iterator: <div class="fragment"><div class="line">std::vector&lt;int&gt; input = {42, 1337, 52};</div>
<div class="line">std::optional&lt;size_t&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input).findIdx(1337);</div>
<div class="line"><span class="comment">// output == Some(1)</span></div>
</div><!-- fragment --></li>
<li>When item is not found in the iterator: <div class="fragment"><div class="line">std::vector&lt;int&gt; input = {<span class="stringliteral">&quot;42&quot;</span>, <span class="stringliteral">&quot;1337&quot;</span>, <span class="stringliteral">&quot;52&quot;</span>};</div>
<div class="line">std::optional&lt;size_t&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input).findIdx(<span class="stringliteral">&quot;not found&quot;</span>);</div>
<div class="line"><span class="comment">// output == None</span></div>
</div><!-- fragment --> </li>
</ul>

<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l00535">535</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>

</div>
</div>
<a id="a36e35fb8446e4c302e48a0a3b2cdca86" name="a36e35fb8446e4c302e48a0a3b2cdca86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36e35fb8446e4c302e48a0a3b2cdca86">&#9670;&nbsp;</a></span>findIdx() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<div class="memtemplate">
template&lt;std::invocable&lt; const <a class="el" href="classCXXIter_1_1IterApi.html#a628012452f851b7099d919218e2a5512">ItemOwned</a> &amp; &gt; TFindFn&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; size_t &gt; <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::findIdx </td>
          <td>(</td>
          <td class="paramtype">TFindFn&#160;</td>
          <td class="paramname"><em>findFn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search for the iterator with the given <code>findFn</code>, and return the index of the element from this iterator, for which the <code>findFn</code> returned <code>true</code> the first time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">findFn</td><td>Lambda invoked for each element of this stream, to determined whether it is the item that is searched for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index of the first element from this stream, for which the invocation to the given <code>findFn</code> returned <code>true</code>.</dd></dl>
<p>Usage Example:</p><ul>
<li>When item is found in the iterator: <div class="fragment"><div class="line">std::vector&lt;int&gt; input = {1337, 31337, 41, 43, 42, 64};</div>
<div class="line">std::optional&lt;size_t&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input)</div>
<div class="line">    .findIdx([](<span class="keywordtype">int</span> item) { <span class="keywordflow">return</span> (item % 2 == 0); });</div>
<div class="line"><span class="comment">// output == Some(4)</span></div>
</div><!-- fragment --></li>
<li>When item is not found in the iterator: <div class="fragment"><div class="line">std::vector&lt;int&gt; input = {1337, 31337, 41, 43};</div>
<div class="line">std::optional&lt;size_t&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input)</div>
<div class="line">    .findIdx([](<span class="keywordtype">int</span> item) { <span class="keywordflow">return</span> (item % 2 == 0); });</div>
<div class="line"><span class="comment">// output == None</span></div>
</div><!-- fragment --> </li>
</ul>

<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l00567">567</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classCXXIter_1_1IterApi_a36e35fb8446e4c302e48a0a3b2cdca86_cgraph.svg" width="392" height="60"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a20aea92a66ad20c05d914944968d4f26" name="a20aea92a66ad20c05d914944968d4f26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20aea92a66ad20c05d914944968d4f26">&#9670;&nbsp;</a></span>flagLast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">op::FlagLast&lt; TSelf &gt; <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::flagLast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a new iterator that tags each element with a boolean value specifying whether the element is the last one in the iterator. Boolean and actual iterator element are stored in a <code>std::pair</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>A new iterator whose elements are <code>std::pair</code> with the iterator element in the first, and a boolean flag specifying whether the element will be the last one in the second slot.</dd></dl>
<p>Usage Example:</p><ul>
<li>Flag last element in filtered iterator <div class="fragment"><div class="line">   std::vector&lt;std::string&gt; input = {<span class="stringliteral">&quot;1337&quot;</span>, <span class="stringliteral">&quot;42&quot;</span>, <span class="stringliteral">&quot;420&quot;</span>, <span class="stringliteral">&quot;64&quot;</span>};</div>
<div class="line">   std::vector&lt;std::pair&lt;std::string&amp;, bool&gt;&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input)</div>
<div class="line">       .filter([](<span class="keyword">const</span> std::string&amp; el) { <span class="keywordflow">return</span> el.size() &gt;= 3; })</div>
<div class="line">       .<a class="code hl_function" href="classCXXIter_1_1IterApi.html#a20aea92a66ad20c05d914944968d4f26">flagLast</a>()</div>
<div class="line">       .collect&lt;std::vector&gt;();</div>
<div class="line"><span class="comment">// output == {{&quot;1337&quot;, false}, {&quot;420&quot;, true}}</span></div>
<div class="ttc" id="aclassCXXIter_1_1IterApi_html_a20aea92a66ad20c05d914944968d4f26"><div class="ttname"><a href="classCXXIter_1_1IterApi.html#a20aea92a66ad20c05d914944968d4f26">CXXIter::IterApi::flagLast</a></div><div class="ttdeci">op::FlagLast&lt; TSelf &gt; flagLast()</div><div class="ttdoc">Constructs a new iterator that tags each element with a boolean value specifying whether the element ...</div><div class="ttdef"><b>Definition:</b> <a href="CXXIter_8h_source.html#l01334">CXXIter.h:1334</a></div></div>
</div><!-- fragment --></li>
<li>Use last flag to filter (remove last element from iterator) <div class="fragment"><div class="line">   std::vector&lt;std::string&gt; input = {<span class="stringliteral">&quot;1337&quot;</span>, <span class="stringliteral">&quot;42&quot;</span>, <span class="stringliteral">&quot;64&quot;</span>};</div>
<div class="line">   std::vector&lt;std::pair&lt;std::string&amp;, bool&gt;&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input)</div>
<div class="line">           .flagLast()</div>
<div class="line">           .filter([](<span class="keyword">const</span> std::pair&lt;std::string&amp;, bool&gt;&amp; el) { <span class="keywordflow">return</span> !el.second; })</div>
<div class="line">           .collect&lt;std::vector&gt;();</div>
<div class="line"><span class="comment">// output == {{&quot;1337&quot;, false}, {&quot;42&quot;, false}}</span></div>
</div><!-- fragment --> </li>
</ul>

<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l01334">1334</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>

</div>
</div>
<a id="ad8985f7682655e5a925329fcd971b482" name="ad8985f7682655e5a925329fcd971b482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8985f7682655e5a925329fcd971b482">&#9670;&nbsp;</a></span>flatMap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::flatMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an iterator that flattens the iterable elements of this iterator. </p>
<p >This works by pulling elements from this iterator, turning them into iterators themselves, and merging them into the stream of the resulting iterator. This only resolves one layer of nesting, and the elements of this iterator have to be supported by <a class="el" href="namespaceCXXIter.html" title="CXXIter.">CXXIter</a> (by a fitting <code>SourceTrait</code> implementation). </p><dl class="section return"><dt>Returns</dt><dd>New iterator that pulls values from this iterator, and flattens the contained iterable into the new iterator's stream.</dd></dl>
<p>Usage Example: </p><div class="fragment"><div class="line">std::vector&lt;std::vector&lt;int&gt;&gt; input = {{1337, 42}, {6, 123, 7888}};</div>
<div class="line">std::vector&lt;int&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(std::move(input))</div>
<div class="line">    .flatMap()</div>
<div class="line">    .collect&lt;std::vector&gt;(); <span class="comment">// collect into vector containing {1337, 42, 6, 123, 7888}</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l01660">1660</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classCXXIter_1_1IterApi_ad8985f7682655e5a925329fcd971b482_cgraph.svg" width="190" height="60"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a165695af4dc2acf1cf6eadd3ae6c2fc2" name="a165695af4dc2acf1cf6eadd3ae6c2fc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a165695af4dc2acf1cf6eadd3ae6c2fc2">&#9670;&nbsp;</a></span>flatMap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<div class="memtemplate">
template&lt;std::invocable&lt; <a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a> &amp;&amp; &gt; TFlatMapFn&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::flatMap </td>
          <td>(</td>
          <td class="paramtype">TFlatMapFn&#160;</td>
          <td class="paramname"><em>mapFn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an iterator that works like <a class="el" href="classCXXIter_1_1IterApi.html#ad8f3454d96494c248abf2e740442e6b6" title="Creates an iterator that uses the given mapFn to map each element from this iterator to elements of t...">map()</a>, but flattens nested containers. </p>
<p >This works by pulling elements from this iterator, passing them to the given <code>mapFn</code>, and then taking the returned values to turn them into iterators themselves, to merge them into the stream of the resulting iterator. This only resolves one layer of nesting, and values returned by <code>mapFn</code> have to be supported by <a class="el" href="namespaceCXXIter.html" title="CXXIter.">CXXIter</a> (by a fitting <code>SourceTrait</code> implementation). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mapFn</td><td>Function that returns a nesting container, that should be merged into the returned iterator's stream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New iterator that pulls values from this iterator, maps them to a nested container, which is then flattened into the new iterator's stream of elements.</dd></dl>
<p>Usage Example: </p><div class="fragment"><div class="line">std::vector&lt;std::pair&lt;std::string, std::vector&lt;int&gt;&gt;&gt; input = {{<span class="stringliteral">&quot;first pair&quot;</span>, {1337, 42}}, {<span class="stringliteral">&quot;second pair&quot;</span>, {6, 123, 7888}}};</div>
<div class="line">std::vector&lt;int&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(std::move(input))</div>
<div class="line">    .flatMap([](<span class="keyword">auto</span>&amp;&amp; item) { <span class="keywordflow">return</span> std::get&lt;1&gt;(item); }) <span class="comment">// flatten the std::vector&lt;int&gt; from the pair</span></div>
<div class="line">    .collect&lt;std::vector&gt;(); <span class="comment">// collect into vector containing {1337, 42, 6, 123, 7888}</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l01559">1559</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>

</div>
</div>
<a id="a16bc04471483e7ce71726036befa551e" name="a16bc04471483e7ce71726036befa551e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16bc04471483e7ce71726036befa551e">&#9670;&nbsp;</a></span>fold()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<div class="memtemplate">
template&lt;typename TResult , std::invocable&lt; TResult &amp;, <a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a> &amp;&amp; &gt; FoldFn&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TResult <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::fold </td>
          <td>(</td>
          <td class="paramtype">TResult&#160;</td>
          <td class="paramname"><em>startValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FoldFn&#160;</td>
          <td class="paramname"><em>foldFn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Consumer that executes the given <code>foldFn</code> for each item in this iterator, to apply to a working value, which is passed on and passed as second argument to the next call to <code>foldFn</code>. </p>
<dl class="section note"><dt>Note</dt><dd>This consumes the iterator. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startValue</td><td>The initial value of the working value passed to <code>foldFn</code>. </td></tr>
    <tr><td class="paramname">foldFn</td><td>Function called for each element in this iterator, passed the current workingValue and an element from this iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The workingValue from the last call to <code>foldFn</code> for the last element from this iterator.</dd></dl>
<p>Usage Example: </p><div class="fragment"><div class="line">   std::vector&lt;double&gt; input = {1.331335363800390, 1.331335363800390, 1.331335363800390, 1.331335363800390};</div>
<div class="line">   <span class="keywordtype">double</span> output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input)</div>
<div class="line">       .fold(1.0, [](<span class="keywordtype">double</span>&amp; workingValue, <span class="keywordtype">double</span> item) {</div>
<div class="line">           workingValue *= item;</div>
<div class="line">       });</div>
<div class="line"><span class="comment">// output ~ 3.141592653589793</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l00355">355</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classCXXIter_1_1IterApi_a16bc04471483e7ce71726036befa551e_cgraph.svg" width="599" height="60"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="aad1cbb262290264fc2e12d80492ad066" name="aad1cbb262290264fc2e12d80492ad066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad1cbb262290264fc2e12d80492ad066">&#9670;&nbsp;</a></span>forEach()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<div class="memtemplate">
template&lt;typename TUseFn &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::forEach </td>
          <td>(</td>
          <td class="paramtype">TUseFn&#160;</td>
          <td class="paramname"><em>useFn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Consumer that calls the given function <code>useFn</code> for each of the elements in this iterator. </p>
<dl class="section note"><dt>Note</dt><dd>This consumes the iterator. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">useFn</td><td>Function called for each of the elements in this iterator.</td></tr>
  </table>
  </dd>
</dl>
<p>Usage Example: </p><div class="fragment"><div class="line">std::vector&lt;std::string&gt; input = {<span class="stringliteral">&quot;1337&quot;</span>, <span class="stringliteral">&quot;42&quot;</span>, <span class="stringliteral">&quot;64&quot;</span>};</div>
<div class="line">std::vector&lt;std::string&gt; output;</div>
<div class="line"><a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input)</div>
<div class="line">        .forEach([&amp;output](std::string&amp; item) {</div>
<div class="line">            output.push_back(std::forward&lt;std::string&gt;(item));</div>
<div class="line">        });</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l00243">243</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classCXXIter_1_1IterApi_aad1cbb262290264fc2e12d80492ad066_cgraph.svg" width="396" height="60"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a859ed47310bc0aade5e6d4378433ac84" name="a859ed47310bc0aade5e6d4378433ac84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a859ed47310bc0aade5e6d4378433ac84">&#9670;&nbsp;</a></span>generateFrom()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<div class="memtemplate">
template&lt;GeneratorFromFunction&lt; <a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a> &gt; TGeneratorFn&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::generateFrom </td>
          <td>(</td>
          <td class="paramtype">TGeneratorFn&#160;</td>
          <td class="paramname"><em>generatorFn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new iterator containing the items that the given generator produces for each element in this iterator. </p>
<p >Conceptually, this method is very similar to <a class="el" href="classCXXIter_1_1IterApi.html#ad8985f7682655e5a925329fcd971b482" title="Creates an iterator that flattens the iterable elements of this iterator.">flatMap()</a> since it allows to take one element from this iterator, and returning an arbitrary amount of new elements into the resulting iterator. A big difference is, that with <a class="el" href="classCXXIter_1_1IterApi.html#a859ed47310bc0aade5e6d4378433ac84" title="Creates a new iterator containing the items that the given generator produces for each element in thi...">generateFrom()</a>, elements can be produced on the fly using c++20 coroutines, while with <a class="el" href="classCXXIter_1_1IterApi.html#ad8985f7682655e5a925329fcd971b482" title="Creates an iterator that flattens the iterable elements of this iterator.">flatMap()</a> they need to be present in a supported container at once - taking up memory. The given <code>generatorFn</code> is run for each element in this iterator, producing a generator. This generator is then driven to completion, piping every element it produced into the resulting iterator. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">generatorFn</td><td><a class="el" href="classCXXIter_1_1Generator.html" title="Generator that C++20 coroutines passed to CXXIter::IterApi::generateFrom() have to return....">Generator</a> function that is executed for each element of this iterator. This function can use co_yield to produce as many elements as it wants. Its return value has to be explicitly specified as <a class="el" href="classCXXIter_1_1Generator.html" title="Generator that C++20 coroutines passed to CXXIter::IterApi::generateFrom() have to return....">CXXIter::Generator</a> with the generated type as template parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Returning references from the generator is supported. Make sure your references stay valid until they are read, though. </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Special care has to be taken with respect to the argument types of the given <code>generatorFn</code>. The generator must take the elements of the stream by-value (copied). If the elements in the stream are moved through the stream, the <code>generatorFn</code> must take them as their owned type. If the elements are passed as references through the stream, the <code>generatorFn</code> can take them as references. If you are getting spurious SEGFAULTs - check your parameter types!</dd></dl>
<p>Usage Example:</p>
<p >The example shows a generator that repeats the strings from the source, depending on the string's lengths. Special attention in these examples should be mainly on the parameter types, as well as the explicitly specified return values of the given generator functions.</p>
<ul>
<li>Using <a class="el" href="classCXXIter_1_1IterApi.html#a859ed47310bc0aade5e6d4378433ac84" title="Creates a new iterator containing the items that the given generator produces for each element in thi...">generateFrom()</a> with a move source, that passes elements by move (generator clones elements and passes them on as owned clones)<br  />
Here, the type of the elements passed through the iterator are owned <code>std::string</code> by move. So the type the generator has to take as parameter is an owned <code>std::string</code>. <div class="fragment"><div class="line">std::vector&lt;std::string&gt; input = {<span class="stringliteral">&quot;1337&quot;</span>, <span class="stringliteral">&quot;42&quot;</span>};</div>
<div class="line">std::vector&lt;std::string&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(std::move(input))</div>
<div class="line">        .generateFrom([](std::string item) -&gt; <a class="code hl_class" href="classCXXIter_1_1Generator.html">CXXIter::Generator&lt;std::string&gt;</a> {</div>
<div class="line">            <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = 0; i &lt; item.size(); ++i) {</div>
<div class="line">                <span class="keyword">co_yield</span> item;</div>
<div class="line">            }</div>
<div class="line">        })</div>
<div class="line">        .collect&lt;std::vector&gt;();</div>
<div class="line"><span class="comment">// output == { &quot;1337&quot;, &quot;1337&quot;, &quot;1337&quot;, &quot;1337&quot;, &quot;42&quot;, &quot;42&quot; }</span></div>
<div class="ttc" id="aclassCXXIter_1_1Generator_html"><div class="ttname"><a href="classCXXIter_1_1Generator.html">CXXIter::Generator</a></div><div class="ttdoc">Generator that C++20 coroutines passed to CXXIter::IterApi::generateFrom() have to return....</div><div class="ttdef"><b>Definition:</b> <a href="Generator_8h_source.html#l00021">Generator.h:21</a></div></div>
</div><!-- fragment --></li>
<li>Using <a class="el" href="classCXXIter_1_1IterApi.html#a859ed47310bc0aade5e6d4378433ac84" title="Creates a new iterator containing the items that the given generator produces for each element in thi...">generateFrom()</a> with a reference source, that passes elements as references (generator clones elements and passes them on as owned clones)<br  />
Here, the type of the elements passed through the iterator are const <code>std::string</code> references. So the type the generator takes can either be a const <code>std::string</code> reference (because they don't reference something temporary, but are references from the permanent source) - or as an owned <code>std::string</code>. <div class="fragment"><div class="line">std::vector&lt;std::string&gt; input = {<span class="stringliteral">&quot;1337&quot;</span>, <span class="stringliteral">&quot;42&quot;</span>};</div>
<div class="line">std::vector&lt;std::string&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input)</div>
<div class="line">        .generateFrom([](<span class="keyword">const</span> std::string&amp; item) -&gt; <a class="code hl_class" href="classCXXIter_1_1Generator.html">CXXIter::Generator&lt;std::string&gt;</a> {</div>
<div class="line">            <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = 0; i &lt; item.size(); ++i) {</div>
<div class="line">                <span class="keyword">co_yield</span> item;</div>
<div class="line">            }</div>
<div class="line">        })</div>
<div class="line">        .collect&lt;std::vector&gt;();</div>
<div class="line"><span class="comment">// output == { &quot;1337&quot;, &quot;1337&quot;, &quot;1337&quot;, &quot;1337&quot;, &quot;42&quot;, &quot;42&quot; }</span></div>
</div><!-- fragment --></li>
<li>Using <a class="el" href="classCXXIter_1_1IterApi.html#a859ed47310bc0aade5e6d4378433ac84" title="Creates a new iterator containing the items that the given generator produces for each element in thi...">generateFrom()</a> with a reference source, that passes elements as references (generator clones references to elements - and passes on the copied references)<br  />
<div class="fragment"><div class="line">std::vector&lt;std::string&gt; input = {<span class="stringliteral">&quot;1337&quot;</span>, <span class="stringliteral">&quot;42&quot;</span>};</div>
<div class="line">std::vector&lt;std::string&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input)</div>
<div class="line">        .generateFrom([](<span class="keyword">const</span> std::string&amp; item) -&gt; <a class="code hl_class" href="classCXXIter_1_1Generator.html">CXXIter::Generator&lt;const std::string&amp;&gt;</a> {</div>
<div class="line">            <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = 0; i &lt; item.size(); ++i) {</div>
<div class="line">                <span class="keyword">co_yield</span> item;</div>
<div class="line">            }</div>
<div class="line">        })</div>
<div class="line">        .collect&lt;std::vector&gt;();</div>
<div class="line"><span class="comment">// output == { &quot;1337&quot;, &quot;1337&quot;, &quot;1337&quot;, &quot;1337&quot;, &quot;42&quot;, &quot;42&quot; }</span></div>
</div><!-- fragment --> </li>
</ul>

<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l01637">1637</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>

</div>
</div>
<a id="aa19a261cd49deb306a1558de75af19c4" name="aa19a261cd49deb306a1558de75af19c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa19a261cd49deb306a1558de75af19c4">&#9670;&nbsp;</a></span>groupBy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<div class="memtemplate">
template&lt;std::invocable&lt; const <a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a> &amp; &gt; TGroupIdentifierFn&gt; <br />
requires util::is_hashable&lt;std::invoke_result_t&lt;TGroupIdentifierFn, const <a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a>&amp;&gt;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::groupBy </td>
          <td>(</td>
          <td class="paramtype">TGroupIdentifierFn&#160;</td>
          <td class="paramname"><em>groupIdentFn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Groups the elements of this iterator according to the values returned by the given <code>groupidentFn</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">groupIdentFn</td><td>Function called for each element from this iterator, to determine the grouping value, that is then used to identify the group an item belongs to. The type returned by this function has to implement <code>std::hash&lt;&gt;</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New iterator whose elements are the calculated groups from the values of this iterator, in the form of a <code>std::pair&lt;&gt;</code> with the group identifier as first value, and a <code>std::vector</code> of all values in the group as second value. </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>GroupBy requires to first drain the input iterator, before being able to supply a single element. This leads to additional memory usage.</dd></dl>
<p>Usage Example: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>CakeMeasurement {</div>
<div class="line">   std::string cakeType;</div>
<div class="line">   <span class="keywordtype">float</span> cakeWeight;</div>
<div class="line">   <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> CakeMeasurement&amp; o)<span class="keyword"> const </span>{</div>
<div class="line">       <span class="keywordflow">return</span> cakeType == o.cakeType &amp;&amp; cakeWeight == o.cakeWeight;</div>
<div class="line">   }</div>
<div class="line">};</div>
<div class="line">std::vector&lt;CakeMeasurement&gt; input = { {<span class="stringliteral">&quot;ApplePie&quot;</span>, 1.3f}, {<span class="stringliteral">&quot;Sacher&quot;</span>, 0.5f}, {<span class="stringliteral">&quot;ApplePie&quot;</span>, 1.8f} };</div>
<div class="line">std::unordered_map&lt;std::string, std::vector&lt;CakeMeasurement&gt;&gt;  output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input)</div>
<div class="line">   .groupBy([](<span class="keyword">const</span> CakeMeasurement&amp; item) { <span class="keywordflow">return</span> item.cakeType; })</div>
<div class="line">   .collect&lt;std::unordered_map&gt;();</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l01998">1998</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>

</div>
</div>
<a id="a037dc6c6a07bbda8b580ef9ea266db08" name="a037dc6c6a07bbda8b580ef9ea266db08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a037dc6c6a07bbda8b580ef9ea266db08">&#9670;&nbsp;</a></span>indexed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::indexed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a new iterator that tags each element of this iterator with the corresponding index, stored in a <code>std::pair</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>A new iterator whose elements are <code>std::pair</code> with an element index in the first, and the original iterator's corresponding element in the second slot.</dd></dl>
<p>Usage Example: </p><div class="fragment"><div class="line">   std::vector&lt;std::string&gt; input = {<span class="stringliteral">&quot;1337&quot;</span>, <span class="stringliteral">&quot;42&quot;</span>, <span class="stringliteral">&quot;64&quot;</span>};</div>
<div class="line">   std::vector&lt;std::pair&lt;size_t, std::string&amp;&gt;&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input)</div>
<div class="line">       .indexed()</div>
<div class="line">       .collect&lt;std::vector&gt;();</div>
<div class="line"><span class="comment">// output == {{0, &quot;1337&quot;}, {1, &quot;42&quot;}, {2, &quot;64&quot;}}</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l01301">1301</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classCXXIter_1_1IterApi_a037dc6c6a07bbda8b580ef9ea266db08_cgraph.svg" width="399" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a0b19694e4307cbc0387dab5c715e73e2" name="a0b19694e4307cbc0387dab5c715e73e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b19694e4307cbc0387dab5c715e73e2">&#9670;&nbsp;</a></span>intersperse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<div class="memtemplate">
template&lt;typename TOtherIterator &gt; <br />
requires (std::is_same_v&lt;<a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a>, typename TOtherIterator::Item&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">op::Intersperser&lt; TSelf, TOtherIterator &gt; <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::intersperse </td>
          <td>(</td>
          <td class="paramtype">TOtherIterator &amp;&amp;&#160;</td>
          <td class="paramname"><em>otherIterator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw elements from the given <code>otherIterator</code> and use the returned elements as separators between the elements of this iterator. </p>
<p >This draws one element "into the future" of this iterator, in order to determine if another separator element from the given <code>otherIterator</code> is required. The resulting iterator ends if either this iterator or the <code>otherIterator</code> has no more elements to pull. The resulting iterator will always start and end on an element from this iterator. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">otherIterator</td><td>Iterator whose elements will be inserted as separator elements between the elements of this iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New iterator that uses the given <code>otherIterator's</code> elements as separators between this iterator's elements.</dd></dl>
<p>Usage Example:</p><ul>
<li>Using infinite separator iterator (int) <div class="fragment"><div class="line">std::vector&lt;int&gt; input = { 1, 2, 3, 4, 5, 6 };</div>
<div class="line">std::vector&lt;int&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input).copied()</div>
<div class="line">    .intersperse(<a class="code hl_function" href="namespaceCXXIter.html#a8db3d258c4fa18c3a122fd13b916f4e0">CXXIter::repeat</a>(0))</div>
<div class="line">    .collect&lt;std::vector&gt;();</div>
<div class="line"><span class="comment">// output == {1, 0, 2, 0, 3, 0, 4, 0, 5, 0, 6}</span></div>
<div class="ttc" id="anamespaceCXXIter_html_a8db3d258c4fa18c3a122fd13b916f4e0"><div class="ttname"><a href="namespaceCXXIter.html#a8db3d258c4fa18c3a122fd13b916f4e0">CXXIter::repeat</a></div><div class="ttdeci">Repeater&lt; TItem &gt; repeat(const TItem &amp;item, std::optional&lt; size_t &gt; cnt={})</div><div class="ttdoc">Construct a CXXIter iterator, by repeating the given item cnt times.</div><div class="ttdef"><b>Definition:</b> <a href="CXXIter_8h_source.html#l02251">CXXIter.h:2251</a></div></div>
</div><!-- fragment --></li>
<li>Using infinite separator iterator (string) <div class="fragment"><div class="line">std::vector&lt;std::string&gt; input = { <span class="stringliteral">&quot;Apple&quot;</span>, <span class="stringliteral">&quot;Orange&quot;</span>, <span class="stringliteral">&quot;Cake&quot;</span> };</div>
<div class="line">std::vector&lt;std::string&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input).copied()</div>
<div class="line">    .intersperse(CXXIter::repeat&lt;std::string&gt;(<span class="stringliteral">&quot;, &quot;</span>))</div>
<div class="line">    .collect&lt;std::vector&gt;();</div>
<div class="line"><span class="comment">// output == {&quot;Apple&quot;, &quot;, &quot;, &quot;Orange&quot;, &quot;, &quot;, &quot;Cake&quot;}</span></div>
</div><!-- fragment --></li>
<li>Using finite separator iterator that ends earlier than source iterator <div class="fragment"><div class="line">std::vector&lt;int&gt; input = { 1, 2, 3, 4, 5, 6 };</div>
<div class="line">std::vector&lt;int&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input).copied()</div>
<div class="line">    .intersperse(<a class="code hl_function" href="namespaceCXXIter.html#a4b4d837f5716b2f5fd7c3098268c582c">CXXIter::range</a>(100, 102, 1))</div>
<div class="line">    .collect&lt;std::vector&gt;();</div>
<div class="line"><span class="comment">// output == {1, 100, 2, 101, 3, 102, 4}</span></div>
<div class="ttc" id="anamespaceCXXIter_html_a4b4d837f5716b2f5fd7c3098268c582c"><div class="ttname"><a href="namespaceCXXIter.html#a4b4d837f5716b2f5fd7c3098268c582c">CXXIter::range</a></div><div class="ttdeci">Range&lt; TValue &gt; range(TValue from, TValue to, TValue step=1)</div><div class="ttdoc">Construct a CXXIter iterator that yields all elements in the range between [from, to] (inclusive both...</div><div class="ttdef"><b>Definition:</b> <a href="CXXIter_8h_source.html#l02279">CXXIter.h:2279</a></div></div>
</div><!-- fragment --> </li>
</ul>

<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l01966">1966</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>

</div>
</div>
<a id="ac706806233525343ea38dc7e78f2faeb" name="ac706806233525343ea38dc7e78f2faeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac706806233525343ea38dc7e78f2faeb">&#9670;&nbsp;</a></span>last()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCXXIter_1_1IterValue.html">IterValue</a>&lt; <a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a> &gt; <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::last </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Consumer that yields the last element of this iterator. </p>
<dl class="section note"><dt>Note</dt><dd>This consumes the iterator. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The last element of this iterator (if any).</dd></dl>
<p>Usage Example:</p><ul>
<li>For a non-empty iterator <div class="fragment"><div class="line">std::vector&lt;int&gt; input = {42, 1337, 52};</div>
<div class="line">std::optional&lt;int&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input)</div>
<div class="line">   .last()</div>
<div class="line">   .toStdOptional();</div>
<div class="line"><span class="comment">// output == Some(52)</span></div>
</div><!-- fragment --></li>
<li>For an empty iterator: <div class="fragment"><div class="line">std::vector&lt;int&gt; input = {};</div>
<div class="line">std::optional&lt;int&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input)</div>
<div class="line">   .last()</div>
<div class="line">   .toStdOptional();</div>
<div class="line"><span class="comment">// output == None</span></div>
</div><!-- fragment --> </li>
</ul>

<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l01206">1206</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classCXXIter_1_1IterApi_ac706806233525343ea38dc7e78f2faeb_cgraph.svg" width="599" height="60"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ad8f3454d96494c248abf2e740442e6b6" name="ad8f3454d96494c248abf2e740442e6b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8f3454d96494c248abf2e740442e6b6">&#9670;&nbsp;</a></span>map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<div class="memtemplate">
template&lt;std::invocable&lt; <a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a> &amp;&amp; &gt; TMapFn&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::map </td>
          <td>(</td>
          <td class="paramtype">TMapFn&#160;</td>
          <td class="paramname"><em>mapFn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an iterator that uses the given <code>mapFn</code> to map each element from this iterator to elements of the new iterator. </p>
<p >This pulls a new value from this iterator, maps it to a new value (can have a completely new type) using the given <code>mapFn</code> and then yields that as new item for thew newly created iterator. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mapFn</td><td>Function that maps items from this iterator to a new value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New iterator that maps the values from this iterator to new values, using the given <code>mapFn</code>.</dd></dl>
<p>Usage Example: </p><div class="fragment"><div class="line">std::vector&lt;int&gt; input = {1337, 42};</div>
<div class="line">std::unordered_map&lt;int, std::string&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input)</div>
<div class="line">    .map([](<span class="keywordtype">int</span> i) { <span class="keywordflow">return</span> std::make_pair(i, std::to_string(i)); }) <span class="comment">// construct pair</span></div>
<div class="line">    .collect&lt;std::unordered_map&gt;(); <span class="comment">// collect into map</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l01533">1533</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>

</div>
</div>
<a id="ab269288401b9ace95379eb94bc3a1dfe" name="ab269288401b9ace95379eb94bc3a1dfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab269288401b9ace95379eb94bc3a1dfe">&#9670;&nbsp;</a></span>max()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCXXIter_1_1IterValue.html">IterValue</a>&lt; <a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a> &gt; <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::max </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Consumer that yields the largest element from this iterator. </p>
<dl class="section note"><dt>Note</dt><dd>This consumes the iterator. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classCXXIter_1_1IterValue.html" title="Container that is used to pass elements through CXXIter&#39;s iterator pipelines.">CXXIter::IterValue</a> optional either containing the largest element of this iterator (if any), or empty otherwise.</dd></dl>
<p>Usage Example:</p><ul>
<li>For a non-empty iterator <div class="fragment"><div class="line">std::vector&lt;int&gt; input = {42, 1337, 52};</div>
<div class="line">std::optional&lt;int&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input)</div>
<div class="line">   .max().toStdOptional();</div>
<div class="line"><span class="comment">// output == Some(1337)</span></div>
</div><!-- fragment --></li>
<li>For an empty iterator: <div class="fragment"><div class="line">std::vector&lt;int&gt; input = {};</div>
<div class="line">std::optional&lt;int&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input)</div>
<div class="line">   .max().toStdOptional();</div>
<div class="line"><span class="comment">// output == None</span></div>
</div><!-- fragment --> </li>
</ul>

<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l00975">975</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="classCXXIter_1_1IterApi_ab269288401b9ace95379eb94bc3a1dfe_cgraph.svg" width="100%" height="462"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>

</div>
</div>
<a id="ab52a8aecfbfa75c7ab5606628831687e" name="ab52a8aecfbfa75c7ab5606628831687e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab52a8aecfbfa75c7ab5606628831687e">&#9670;&nbsp;</a></span>maxBy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<div class="memtemplate">
template&lt;typename TMaxValueExtractFn &gt; <br />
requires requires(const std::invoke_result_t&lt;TMaxValueExtractFn, <a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a>&amp;&amp;&gt;&amp; a, std::remove_cvref_t&lt;decltype(a)&gt; ownedA) { { a &gt; a }; { ownedA = ownedA }; }</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCXXIter_1_1IterValue.html">IterValue</a>&lt; <a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a> &gt; <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::maxBy </td>
          <td>(</td>
          <td class="paramtype">TMaxValueExtractFn&#160;</td>
          <td class="paramname"><em>compValueExtractFn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Consumer that yields the largest element from this iterator. Comparison of items is done using the comparison values returned by invoking the given <code>compValueExtractFn</code> on each element. </p>
<dl class="section note"><dt>Note</dt><dd>This consumes the iterator. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compValueExtractFn</td><td>Function that, given an element from the input iterator as parameter returns the value by which the item should be compared to others. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classCXXIter_1_1IterValue.html" title="Container that is used to pass elements through CXXIter&#39;s iterator pipelines.">CXXIter::IterValue</a> optional either containing the largest element of this iterator (if any), or empty otherwise.</dd></dl>
<p>Usage Example:</p><ul>
<li>For a non-empty iterator <div class="fragment"><div class="line">   std::vector&lt;std::string&gt; input = {<span class="stringliteral">&quot;smol&quot;</span>, <span class="stringliteral">&quot;middle&quot;</span>, <span class="stringliteral">&quot;largeString&quot;</span>};</div>
<div class="line">   std::optional&lt;std::string&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input)</div>
<div class="line">       .maxBy([](<span class="keyword">const</span> std::string&amp; str) { <span class="keywordflow">return</span> str.size(); })</div>
<div class="line">   .toStdOptional();</div>
<div class="line"><span class="comment">// output == Some(&quot;largeString&quot;)</span></div>
</div><!-- fragment --></li>
<li>For an empty iterator: <div class="fragment"><div class="line">   std::vector&lt;std::string&gt; input = {};</div>
<div class="line">   std::optional&lt;std::string&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input)</div>
<div class="line">       .maxBy([](<span class="keyword">const</span> std::string&amp; str) { <span class="keywordflow">return</span> str.size(); })</div>
<div class="line">   .toStdOptional();</div>
<div class="line"><span class="comment">// output == None</span></div>
</div><!-- fragment --> </li>
</ul>

<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l01124">1124</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classCXXIter_1_1IterApi_ab52a8aecfbfa75c7ab5606628831687e_cgraph.svg" width="620" height="216"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="af161ffefa2006ad6df0bd084d7374f51" name="af161ffefa2006ad6df0bd084d7374f51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af161ffefa2006ad6df0bd084d7374f51">&#9670;&nbsp;</a></span>maxIdx()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; size_t &gt; <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::maxIdx </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Consumer that yields the index of the largest element within this iterator. </p>
<dl class="section note"><dt>Note</dt><dd>This consumes the iterator. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Index of the largest element within the input iterator (if any).</dd></dl>
<p>Usage Example:</p><ul>
<li>For a non-empty iterator <div class="fragment"><div class="line">std::vector&lt;int&gt; input = {42, 1337, 52};</div>
<div class="line">std::optional&lt;size_t&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input).maxIdx();</div>
<div class="line"><span class="comment">// output == Some(1)</span></div>
</div><!-- fragment --></li>
<li>For an empty iterator: <div class="fragment"><div class="line">std::vector&lt;int&gt; input = {};</div>
<div class="line">std::optional&lt;size_t&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input).maxIdx();</div>
<div class="line"><span class="comment">// output == None</span></div>
</div><!-- fragment --> </li>
</ul>

<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l00998">998</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="classCXXIter_1_1IterApi_af161ffefa2006ad6df0bd084d7374f51_cgraph.svg" width="100%" height="462"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>

</div>
</div>
<a id="a61dd9812e764db7f0acbc1509cea21ad" name="a61dd9812e764db7f0acbc1509cea21ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61dd9812e764db7f0acbc1509cea21ad">&#9670;&nbsp;</a></span>maxIdxBy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<div class="memtemplate">
template&lt;typename TMaxValueExtractFn &gt; <br />
requires requires(const std::invoke_result_t&lt;TMaxValueExtractFn, <a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a>&amp;&amp;&gt;&amp; a, std::remove_cvref_t&lt;decltype(a)&gt; ownedA) { { a &gt; a }; { ownedA = ownedA }; }</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; size_t &gt; <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::maxIdxBy </td>
          <td>(</td>
          <td class="paramtype">TMaxValueExtractFn&#160;</td>
          <td class="paramname"><em>compValueExtractFn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Consumer that yields the index of the largest element from this iterator. Comparison of items is done using the comparison values returned by invoking the given <code>TCompValueExtractFn</code> on each element. </p>
<dl class="section note"><dt>Note</dt><dd>This consumes the iterator. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compValueExtractFn</td><td>Function that, given an element from the input iterator as parameter, returns the value by which the item should be compared to others. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index of the largest element within the input iterator (if any).</dd></dl>
<p>Usage Example:</p><ul>
<li>For a non-empty iterator <div class="fragment"><div class="line"><span class="keyword">const</span> std::vector&lt;std::string&gt; input = {<span class="stringliteral">&quot;middle&quot;</span>, <span class="stringliteral">&quot;largeString&quot;</span>, <span class="stringliteral">&quot;smol&quot;</span>};</div>
<div class="line">std::optional&lt;size_t&gt; output = <a class="code hl_class" href="classCXXIter_1_1SrcCRef.html">CXXIter::SrcCRef</a>(input)</div>
<div class="line">   .<a class="code hl_function" href="classCXXIter_1_1IterApi.html#a61dd9812e764db7f0acbc1509cea21ad">maxIdxBy</a>([](<span class="keyword">const</span> std::string&amp; str) { <span class="keywordflow">return</span> str.size(); });</div>
<div class="line"><span class="comment">// output = Some(1)</span></div>
<div class="ttc" id="aclassCXXIter_1_1IterApi_html_a61dd9812e764db7f0acbc1509cea21ad"><div class="ttname"><a href="classCXXIter_1_1IterApi.html#a61dd9812e764db7f0acbc1509cea21ad">CXXIter::IterApi::maxIdxBy</a></div><div class="ttdeci">std::optional&lt; size_t &gt; maxIdxBy(TMaxValueExtractFn compValueExtractFn)</div><div class="ttdoc">Consumer that yields the index of the largest element from this iterator. Comparison of items is done...</div><div class="ttdef"><b>Definition:</b> <a href="CXXIter_8h_source.html#l01167">CXXIter.h:1167</a></div></div>
<div class="ttc" id="aclassCXXIter_1_1SrcCRef_html"><div class="ttname"><a href="classCXXIter_1_1SrcCRef.html">CXXIter::SrcCRef</a></div><div class="ttdoc">CXXIter iterator source that immutably borrows the input item source, and passes immutable references...</div><div class="ttdef"><b>Definition:</b> <a href="ContainerSources_8h_source.html#l00142">ContainerSources.h:142</a></div></div>
</div><!-- fragment --></li>
<li>For an empty iterator: <div class="fragment"><div class="line"><span class="keyword">const</span> std::vector&lt;std::string&gt; input = {};</div>
<div class="line">std::optional&lt;size_t&gt; output = <a class="code hl_class" href="classCXXIter_1_1SrcCRef.html">CXXIter::SrcCRef</a>(input)</div>
<div class="line">   .<a class="code hl_function" href="classCXXIter_1_1IterApi.html#a61dd9812e764db7f0acbc1509cea21ad">maxIdxBy</a>([](<span class="keyword">const</span> std::string&amp; str) { <span class="keywordflow">return</span> str.size(); });</div>
<div class="line"><span class="comment">// output = None</span></div>
</div><!-- fragment --> </li>
</ul>

<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l01167">1167</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classCXXIter_1_1IterApi_a61dd9812e764db7f0acbc1509cea21ad_cgraph.svg" width="640" height="267"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a1727767f03cfe2be17ea017e87beb7ab" name="a1727767f03cfe2be17ea017e87beb7ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1727767f03cfe2be17ea017e87beb7ab">&#9670;&nbsp;</a></span>mean()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="namespaceCXXIter.html#a4e698a5b11eca24990a5db359a5e58ec">StatisticNormalization</a> NORM = StatisticNormalization::N, typename TResult  = ItemOwned, typename TCount  = ItemOwned&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; TResult &gt; <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::mean </td>
          <td>(</td>
          <td class="paramtype">TResult&#160;</td>
          <td class="paramname"><em>sumStart</em> = <code>TResult()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Consumer that calculates the mean of all elements of this iterator. </p>
<p >The mean is calculated by first summing up all elements, and then dividing through the number of elements counted while summing. </p><dl class="section note"><dt>Note</dt><dd>This consumes the iterator. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sumStart</td><td>Optional starting point for the sum of all items. Normally uses default ctor of <code>TResult</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The mean of all elements of this iterator. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NORM</td><td>Type of the statistical normalization variant to use for the calculation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceCXXIter.html#a4e698a5b11eca24990a5db359a5e58ec" title="Normalization variant to use while calculating statistics (mean / stddev / ...)">StatisticNormalization</a> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TResult</td><td>Type of the mean-calculation's result. This is also the type used for the sum of all elements. </td></tr>
    <tr><td class="paramname">TCount</td><td>Type the element counter is converted into, before dividing the sum by. This can be necessary, if TResult is a complex object that only supports the division operator for e.g. double.</td></tr>
  </table>
  </dd>
</dl>
<p>Usage Example:</p><ul>
<li>For a non-empty iterator <div class="fragment"><div class="line">std::vector&lt;float&gt; input = {1.0f, 2.0f, 3.0f};</div>
<div class="line">std::optional&lt;float&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input).mean();</div>
<div class="line"><span class="comment">// output == Some(2.0f)</span></div>
</div><!-- fragment --></li>
<li>For an empty iterator: <div class="fragment"><div class="line">std::vector&lt;float&gt; input = {};</div>
<div class="line">std::optional&lt;float&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input).mean();</div>
<div class="line"><span class="comment">// output == None</span></div>
</div><!-- fragment --> </li>
</ul>

<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l00787">787</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="classCXXIter_1_1IterApi_a1727767f03cfe2be17ea017e87beb7ab_cgraph.svg" width="100%" height="300"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>

</div>
</div>
<a id="a8cf454fb870bc6d782f5f4a392c39520" name="a8cf454fb870bc6d782f5f4a392c39520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cf454fb870bc6d782f5f4a392c39520">&#9670;&nbsp;</a></span>min()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCXXIter_1_1IterValue.html">IterValue</a>&lt; <a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a> &gt; <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::min </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Consumer that yields the smallest element from this iterator. </p>
<dl class="section note"><dt>Note</dt><dd>This consumes the iterator. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classCXXIter_1_1IterValue.html" title="Container that is used to pass elements through CXXIter&#39;s iterator pipelines.">CXXIter::IterValue</a> optional either containing the smallest element of this iterator (if any), or empty otherwise.</dd></dl>
<p>Usage Example:</p><ul>
<li>For a non-empty iterator <div class="fragment"><div class="line">std::vector&lt;int&gt; input = {42, 1337, 52};</div>
<div class="line">std::optional&lt;int&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input)</div>
<div class="line">   .min().toStdOptional();</div>
<div class="line"><span class="comment">// output == Some(42)</span></div>
</div><!-- fragment --></li>
<li>For an empty iterator: <div class="fragment"><div class="line">std::vector&lt;int&gt; input = {};</div>
<div class="line">std::optional&lt;int&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input)</div>
<div class="line">   .min().toStdOptional();</div>
<div class="line"><span class="comment">// output == None</span></div>
</div><!-- fragment --> </li>
</ul>

<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l00926">926</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="classCXXIter_1_1IterApi_a8cf454fb870bc6d782f5f4a392c39520_cgraph.svg" width="100%" height="462"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>

</div>
</div>
<a id="a2b119a582aeea0e05e9d6985c4439983" name="a2b119a582aeea0e05e9d6985c4439983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b119a582aeea0e05e9d6985c4439983">&#9670;&nbsp;</a></span>minBy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<div class="memtemplate">
template&lt;typename TCompValueExtractFn &gt; <br />
requires requires(const std::invoke_result_t&lt;TCompValueExtractFn, <a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a>&amp;&amp;&gt;&amp; a, std::remove_cvref_t&lt;decltype(a)&gt; ownedA) { { a &lt; a }; { ownedA = ownedA }; }</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCXXIter_1_1IterValue.html">IterValue</a>&lt; <a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a> &gt; <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::minBy </td>
          <td>(</td>
          <td class="paramtype">TCompValueExtractFn&#160;</td>
          <td class="paramname"><em>compValueExtractFn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Consumer that yields the smallest element from this iterator. Comparison of items is done using the comparison values returned by invoking the given <code>compValueExtractFn</code> on each element. </p>
<dl class="section note"><dt>Note</dt><dd>This consumes the iterator. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compValueExtractFn</td><td>Function that, given an element from the input iterator as parameter returns the value by which the item should be compared to others. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classCXXIter_1_1IterValue.html" title="Container that is used to pass elements through CXXIter&#39;s iterator pipelines.">CXXIter::IterValue</a> optional either containing the smallest element of this iterator (if any), or empty otherwise.</dd></dl>
<p>Usage Example:</p><ul>
<li>For a non-empty iterator <div class="fragment"><div class="line">   std::vector&lt;std::string&gt; input = {<span class="stringliteral">&quot;smol&quot;</span>, <span class="stringliteral">&quot;middle&quot;</span>, <span class="stringliteral">&quot;largeString&quot;</span>};</div>
<div class="line">   std::optional&lt;std::string&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input)</div>
<div class="line">       .minBy([](<span class="keyword">const</span> std::string&amp; str) { <span class="keywordflow">return</span> str.size(); })</div>
<div class="line">   .toStdOptional();</div>
<div class="line"><span class="comment">// output == Some(&quot;smol&quot;)</span></div>
</div><!-- fragment --></li>
<li>For an empty iterator: <div class="fragment"><div class="line">   std::vector&lt;std::string&gt; input = {};</div>
<div class="line">   std::optional&lt;std::string&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input)</div>
<div class="line">       .minBy([](<span class="keyword">const</span> std::string&amp; str) { <span class="keywordflow">return</span> str.size(); })</div>
<div class="line">   .toStdOptional();</div>
<div class="line"><span class="comment">// output == None</span></div>
</div><!-- fragment --> </li>
</ul>

<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l01034">1034</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classCXXIter_1_1IterApi_a2b119a582aeea0e05e9d6985c4439983_cgraph.svg" width="616" height="216"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ad191096d655db542272acc7b89f76962" name="ad191096d655db542272acc7b89f76962"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad191096d655db542272acc7b89f76962">&#9670;&nbsp;</a></span>minIdx()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; size_t &gt; <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::minIdx </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Consumer that yields the index of the smallest element within this iterator. </p>
<dl class="section note"><dt>Note</dt><dd>This consumes the iterator. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Index of the smallest element within the input iterator (if any).</dd></dl>
<p>Usage Example:</p><ul>
<li>For a non-empty iterator <div class="fragment"><div class="line">std::vector&lt;int&gt; input = {1337, 42, 52};</div>
<div class="line">std::optional&lt;size_t&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input).minIdx();</div>
<div class="line"><span class="comment">// output == Some(1)</span></div>
</div><!-- fragment --></li>
<li>For an empty iterator: <div class="fragment"><div class="line">std::vector&lt;int&gt; input = {};</div>
<div class="line">std::optional&lt;size_t&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input).minIdx();</div>
<div class="line"><span class="comment">// output == None</span></div>
</div><!-- fragment --> </li>
</ul>

<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l00949">949</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="classCXXIter_1_1IterApi_ad191096d655db542272acc7b89f76962_cgraph.svg" width="100%" height="462"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>

</div>
</div>
<a id="af531c69c1b5edf6d5c30c56ddd0c9500" name="af531c69c1b5edf6d5c30c56ddd0c9500"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af531c69c1b5edf6d5c30c56ddd0c9500">&#9670;&nbsp;</a></span>minIdxBy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<div class="memtemplate">
template&lt;typename TCompValueExtractFn &gt; <br />
requires requires(const std::invoke_result_t&lt;TCompValueExtractFn, <a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a>&amp;&amp;&gt;&amp; a) { { a &lt; a }; }</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; size_t &gt; <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::minIdxBy </td>
          <td>(</td>
          <td class="paramtype">TCompValueExtractFn&#160;</td>
          <td class="paramname"><em>compValueExtractFn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Consumer that yields the index of the smallest element from this iterator. Comparison of items is done using the comparison values returned by invoking the given <code>compValueExtractFn</code> on each element. </p>
<dl class="section note"><dt>Note</dt><dd>This consumes the iterator. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compValueExtractFn</td><td>Function that, given an element from the input iterator as parameter, returns the value by which the item should be compared to others. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index of the smallest element within the input iterator (if any).</dd></dl>
<p>Usage Example:</p><ul>
<li>For a non-empty iterator <div class="fragment"><div class="line"><span class="keyword">const</span> std::vector&lt;std::string&gt; input = {<span class="stringliteral">&quot;middle&quot;</span>, <span class="stringliteral">&quot;smol&quot;</span>, <span class="stringliteral">&quot;largeString&quot;</span>};</div>
<div class="line">std::optional&lt;size_t&gt; output = <a class="code hl_class" href="classCXXIter_1_1SrcCRef.html">CXXIter::SrcCRef</a>(input)</div>
<div class="line">   .<a class="code hl_function" href="classCXXIter_1_1IterApi.html#af531c69c1b5edf6d5c30c56ddd0c9500">minIdxBy</a>([](<span class="keyword">const</span> std::string&amp; str) { <span class="keywordflow">return</span> str.size(); });</div>
<div class="line"><span class="comment">// output = Some(1)</span></div>
<div class="ttc" id="aclassCXXIter_1_1IterApi_html_af531c69c1b5edf6d5c30c56ddd0c9500"><div class="ttname"><a href="classCXXIter_1_1IterApi.html#af531c69c1b5edf6d5c30c56ddd0c9500">CXXIter::IterApi::minIdxBy</a></div><div class="ttdeci">std::optional&lt; size_t &gt; minIdxBy(TCompValueExtractFn compValueExtractFn)</div><div class="ttdoc">Consumer that yields the index of the smallest element from this iterator. Comparison of items is don...</div><div class="ttdef"><b>Definition:</b> <a href="CXXIter_8h_source.html#l01076">CXXIter.h:1076</a></div></div>
</div><!-- fragment --></li>
<li>For an empty iterator: <div class="fragment"><div class="line"><span class="keyword">const</span> std::vector&lt;std::string&gt; input = {};</div>
<div class="line">std::optional&lt;size_t&gt; output = <a class="code hl_class" href="classCXXIter_1_1SrcCRef.html">CXXIter::SrcCRef</a>(input)</div>
<div class="line">   .<a class="code hl_function" href="classCXXIter_1_1IterApi.html#af531c69c1b5edf6d5c30c56ddd0c9500">minIdxBy</a>([](<span class="keyword">const</span> std::string&amp; str) { <span class="keywordflow">return</span> str.size(); });</div>
<div class="line"><span class="comment">// output = None</span></div>
</div><!-- fragment --> </li>
</ul>

<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l01076">1076</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classCXXIter_1_1IterApi_af531c69c1b5edf6d5c30c56ddd0c9500_cgraph.svg" width="636" height="267"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ab1dfa465e7f30e6d8d4fadabd8b092b4" name="ab1dfa465e7f30e6d8d4fadabd8b092b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1dfa465e7f30e6d8d4fadabd8b092b4">&#9670;&nbsp;</a></span>modify()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<div class="memtemplate">
template&lt;std::invocable&lt; <a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a> &amp; &gt; TModifierFn&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">op::InplaceModifier&lt; TSelf, TModifierFn &gt; <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::modify </td>
          <td>(</td>
          <td class="paramtype">TModifierFn&#160;</td>
          <td class="paramname"><em>modifierFn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows to inspect and modify each item in-place, that passes through this iterator. </p>
<p >This can be used instead of a <a class="el" href="classCXXIter_1_1IterApi.html#ad8f3454d96494c248abf2e740442e6b6" title="Creates an iterator that uses the given mapFn to map each element from this iterator to elements of t...">map()</a> with the same type as input and output. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">modifierFn</td><td>Function that is called for each item that passes through this iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator that forwards the items of this iterator, after they have been inspected and potentially modified by the <code>modifierFn</code>.</dd></dl>
<p>Usage Example: </p><div class="fragment"><div class="line">std::unordered_map&lt;int, std::string&gt; input = { {1337, <span class="stringliteral">&quot;1337&quot;</span>}, {42, <span class="stringliteral">&quot;42&quot;</span>} };</div>
<div class="line">std::unordered_map&lt;int, std::string&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input)</div>
<div class="line">    .modify([](<span class="keyword">auto</span>&amp; keyValue) { keyValue.second = <span class="stringliteral">&quot;-&quot;</span> + keyValue.second; }) <span class="comment">// modify input</span></div>
<div class="line">    .collect&lt;std::unordered_map&gt;(); <span class="comment">// copy to output</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l01680">1680</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>

</div>
</div>
<a id="a1a805fbdc20f9eb42e8162d5eb0a1b3e" name="a1a805fbdc20f9eb42e8162d5eb0a1b3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a805fbdc20f9eb42e8162d5eb0a1b3e">&#9670;&nbsp;</a></span>next()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCXXIter_1_1IterValue.html">IterValue</a>&lt; <a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a> &gt; <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::next </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the next element from this iterator (if any), wrapped in a CXXIter::IterValue&lt;&gt;. </p>
<dl class="section note"><dt>Note</dt><dd>If the returned <a class="el" href="classCXXIter_1_1IterValue.html" title="Container that is used to pass elements through CXXIter&#39;s iterator pipelines.">CXXIter::IterValue</a> is empty, there are no elements left in this iterator. Calling <code><a class="el" href="classCXXIter_1_1IterApi.html#a1a805fbdc20f9eb42e8162d5eb0a1b3e" title="Get the next element from this iterator (if any), wrapped in a CXXIter::IterValue&lt;&gt;.">next()</a></code> again after that is undefined behavior. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The next element from this iterator (if any), wrapped in a CXXIter::IterValue&lt;&gt;</dd></dl>
<p>Usage Example: </p><div class="fragment"><div class="line">   std::optional&lt;float&gt; output = CXXIter::range&lt;float&gt;(1.337f, 2.0f, 0.25f)</div>
<div class="line">       .next().toStdOptional();</div>
<div class="line"><span class="comment">// output == Some(1.337f);</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l00177">177</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classCXXIter_1_1IterApi_a1a805fbdc20f9eb42e8162d5eb0a1b3e_cgraph.svg" width="170" height="60"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a7f1f0e435b605b4947eea18fa4762ca0" name="a7f1f0e435b605b4947eea18fa4762ca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f1f0e435b605b4947eea18fa4762ca0">&#9670;&nbsp;</a></span>nextBack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCXXIter_1_1IterValue.html">IterValue</a>&lt; <a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a> &gt; <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::nextBack </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the next element from the back of this iterator (if any), wrapped in a CXXIter::IterValue&lt;&gt;. </p>
<dl class="section note"><dt>Note</dt><dd>If the returned <a class="el" href="classCXXIter_1_1IterValue.html" title="Container that is used to pass elements through CXXIter&#39;s iterator pipelines.">CXXIter::IterValue</a> is empty, there are no elements left in this iterator. Calling <code><a class="el" href="classCXXIter_1_1IterApi.html#a7f1f0e435b605b4947eea18fa4762ca0" title="Get the next element from the back of this iterator (if any), wrapped in a CXXIter::IterValue&lt;&gt;.">nextBack()</a></code> again after that is undefined behavior. </dd>
<dd>
This method only exists if the iterator implements the DoubleEndedIterator trait. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The next element from the back of this iterator (if any), wrapped in a CXXIter::IterValue&lt;&gt;</dd></dl>
<p>Usage Example: </p><div class="fragment"><div class="line">   std::optional&lt;float&gt; output = CXXIter::range&lt;float&gt;(1.337f, 2.0f, 0.25f)</div>
<div class="line">       .nextBack().toStdOptional();</div>
<div class="line"><span class="comment">// output == Some(0.25f);</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l00215">215</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classCXXIter_1_1IterApi_a7f1f0e435b605b4947eea18fa4762ca0_cgraph.svg" width="202" height="60"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="aa0d21f64c103c94930a6965686f61019" name="aa0d21f64c103c94930a6965686f61019"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0d21f64c103c94930a6965686f61019">&#9670;&nbsp;</a></span>nth()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCXXIter_1_1IterValue.html">IterValue</a>&lt; <a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a> &gt; <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::nth </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the <code></code>{n}-th element from this iterator (if available). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Index of the element to return from this iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <code></code>{n}-th element from this iterator.</dd></dl>
<p>Usage Example:</p><ul>
<li>When the n-th element exists: <div class="fragment"><div class="line">   std::vector&lt;int&gt; input = {42, 1337, 52};</div>
<div class="line">   std::optional&lt;int&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input).nth(1).toStdOptional();</div>
<div class="line"><span class="comment">// output == Some(1337)</span></div>
</div><!-- fragment --></li>
<li>When the n-th element does not exist: <div class="fragment"><div class="line">   std::vector&lt;int&gt; input = {42, 1337, 52};</div>
<div class="line">   std::optional&lt;int&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input).nth(10).toStdOptional();</div>
<div class="line"><span class="comment">// output == None</span></div>
</div><!-- fragment --> </li>
</ul>

<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l01231">1231</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classCXXIter_1_1IterApi_aa0d21f64c103c94930a6965686f61019_cgraph.svg" width="367" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ac63528dd525977d236a3c3b050ed1456" name="ac63528dd525977d236a3c3b050ed1456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac63528dd525977d236a3c3b050ed1456">&#9670;&nbsp;</a></span>reverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">op::Reverse&lt; TSelf &gt; <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::reverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a new iterator that provides the elements of this iterator in reverse order. </p>
<dl class="section attention"><dt>Attention</dt><dd>If the underlying iterator implements DoubleEndedIterator it is going to be used and this operation will not have an additional cost. If the underlying iterator does not implement DoubleEndedIterator, it will be emulated by first draining the iterator into a container and then providing those elements in reverse. This leads to additional memory usage. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator that provides the elements of this iterator in reverse order.</dd></dl>
<p>Usage Example: </p><div class="fragment"><div class="line">std::vector&lt;size_t&gt; input = {1, 42, 2, 1337, 3, 4, 69, 5, 6, 5};</div>
<div class="line">std::vector&lt;size_t&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input).copied()</div>
<div class="line">   .reverse()</div>
<div class="line">   .collect&lt;std::vector&gt;();</div>
<div class="line"><span class="comment">// output == { 5, 6, 5, 69, 4, 3, 1337, 2, 42, 1 }</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l01422">1422</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>

</div>
</div>
<a id="ada90a5f5e73ce22a69b21870ee197804" name="ada90a5f5e73ce22a69b21870ee197804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada90a5f5e73ce22a69b21870ee197804">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get this iterator's exact size. </p>
<dl class="section note"><dt>Note</dt><dd>This method only exists if the iterator's exact size is known. Operations like <code><a class="el" href="classCXXIter_1_1IterApi.html#a6fe973bcef3669050b734c6c0c0481bb" title="Constructs a new iterator that only contains the elements from this iterator, for which the given fil...">IterApi::filter</a></code> cause the remaining iterator to have an unknown exact size. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>This iterator's exact number of elements.</dd></dl>
<p>Usage Example:</p><ul>
<li>Valid (Exact number of elements is known): <div class="fragment"><div class="line"><span class="keywordtype">size_t</span> <a class="code hl_function" href="classCXXIter_1_1IterApi.html#ada90a5f5e73ce22a69b21870ee197804">size</a> = CXXIter::range&lt;float&gt;(0.0f, 2.0f, 0.25f)</div>
<div class="line">        .map([](<span class="keywordtype">float</span> blub) { <span class="keywordflow">return</span> std::to_string(blub); })</div>
<div class="line">        .<a class="code hl_function" href="classCXXIter_1_1IterApi.html#af8c752a71a1a7931c711ed6749c62080">sort</a>()</div>
<div class="line">        .intersperse(CXXIter::empty&lt;std::string&gt;())</div>
<div class="line">        .<a class="code hl_function" href="classCXXIter_1_1IterApi.html#ada90a5f5e73ce22a69b21870ee197804">size</a>();</div>
<div class="line"><span class="comment">// size == 8</span></div>
<div class="ttc" id="aclassCXXIter_1_1IterApi_html_ada90a5f5e73ce22a69b21870ee197804"><div class="ttname"><a href="classCXXIter_1_1IterApi.html#ada90a5f5e73ce22a69b21870ee197804">CXXIter::IterApi::size</a></div><div class="ttdeci">size_t size() const</div><div class="ttdoc">Get this iterator's exact size.</div><div class="ttdef"><b>Definition:</b> <a href="CXXIter_8h_source.html#l00160">CXXIter.h:160</a></div></div>
<div class="ttc" id="aclassCXXIter_1_1IterApi_html_af8c752a71a1a7931c711ed6749c62080"><div class="ttname"><a href="classCXXIter_1_1IterApi.html#af8c752a71a1a7931c711ed6749c62080">CXXIter::IterApi::sort</a></div><div class="ttdeci">auto sort()</div><div class="ttdoc">Creates a new iterator that takes the items from this iterator, and passes them on sorted.</div><div class="ttdef"><b>Definition:</b> <a href="CXXIter_8h_source.html#l02064">CXXIter.h:2064</a></div></div>
</div><!-- fragment --></li>
<li>Invalid, does not compile (Exact number of elements is unknown): <div class="fragment"><div class="line"><span class="keywordtype">size_t</span> <a class="code hl_function" href="classCXXIter_1_1IterApi.html#ada90a5f5e73ce22a69b21870ee197804">size</a> = CXXIter::range&lt;float&gt;(0.0f, 2.0f, 0.25f)</div>
<div class="line">    .map([](<span class="keywordtype">float</span> blub) { <span class="keywordflow">return</span> std::to_string(blub); })</div>
<div class="line">    .<a class="code hl_function" href="classCXXIter_1_1IterApi.html#af8c752a71a1a7931c711ed6749c62080">sort</a>()</div>
<div class="line">    .intersperse(CXXIter::empty&lt;std::string&gt;())</div>
<div class="line">    .<a class="code hl_function" href="classCXXIter_1_1IterApi.html#ad8985f7682655e5a925329fcd971b482">flatMap</a>()</div>
<div class="line">    .size();</div>
<div class="ttc" id="aclassCXXIter_1_1IterApi_html_ad8985f7682655e5a925329fcd971b482"><div class="ttname"><a href="classCXXIter_1_1IterApi.html#ad8985f7682655e5a925329fcd971b482">CXXIter::IterApi::flatMap</a></div><div class="ttdeci">auto flatMap()</div><div class="ttdoc">Creates an iterator that flattens the iterable elements of this iterator.</div><div class="ttdef"><b>Definition:</b> <a href="CXXIter_8h_source.html#l01660">CXXIter.h:1660</a></div></div>
</div><!-- fragment --> </li>
</ul>

<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l00160">160</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classCXXIter_1_1IterApi_ada90a5f5e73ce22a69b21870ee197804_cgraph.svg" width="167" height="60"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a9baddc40de1b9c63102e5c5bf886474e" name="a9baddc40de1b9c63102e5c5bf886474e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9baddc40de1b9c63102e5c5bf886474e">&#9670;&nbsp;</a></span>sizeHint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCXXIter_1_1SizeHint.html">SizeHint</a> <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::sizeHint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the bounds on the remaining length of this iterator, estimated from the source and all of the chained iterations on it. </p>
<dl class="section return"><dt>Returns</dt><dd>The estimated bounds on the remaining length of this iterator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l00130">130</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classCXXIter_1_1IterApi_a9baddc40de1b9c63102e5c5bf886474e_cgraph.svg" width="194" height="60"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="acf4cbe6073a887100d549f0bea73a90e" name="acf4cbe6073a887100d549f0bea73a90e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf4cbe6073a887100d549f0bea73a90e">&#9670;&nbsp;</a></span>skip()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">op::SkipN&lt; TSelf &gt; <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::skip </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cnt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an iterator that skips the first <code>cnt</code> elements from this iterator, before it yields the remaining items. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cnt</td><td>Amount of elements to skip from this iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new iterator that skips <code>cnt</code> elements from this iterator, before yielding the remaining items.</dd></dl>
<p>Usage Example: </p><div class="fragment"><div class="line">std::vector&lt;int&gt; input = {42, 42, 42, 42, 1337};</div>
<div class="line">std::vector&lt;int&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input)</div>
<div class="line">    .skip(3) <span class="comment">// skip first 3 values</span></div>
<div class="line">    .collect&lt;std::vector&gt;();</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l01724">1724</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>

</div>
</div>
<a id="abc72090031914ff844c3242fddbd22c2" name="abc72090031914ff844c3242fddbd22c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc72090031914ff844c3242fddbd22c2">&#9670;&nbsp;</a></span>skipWhile()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<div class="memtemplate">
template&lt;std::invocable&lt; const <a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a> &amp; &gt; TSkipPredicate&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">op::SkipWhile&lt; TSelf, TSkipPredicate &gt; <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::skipWhile </td>
          <td>(</td>
          <td class="paramtype">TSkipPredicate&#160;</td>
          <td class="paramname"><em>skipPredicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an iterator that skips the first elements of this iterator, for which the given <code>skipPredicate</code> returns <code>true</code>. </p>
<p >The <code>skipPredicate</code> is only called until it returned <code>false</code> for the first time, after that its job is done. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">skipPredicate</td><td>Predicate that determines the items whether an item at the beginning of this iterator should be skipped (<code>true</code>). Should return <code>false</code> for the first item yielded from the resulted iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new iterator that skips the frist elements from this iterator, until the given <code>skipPredicate</code> returns <code>false</code> for the first time. It then yields all remaining items of this iterator.</dd></dl>
<p>Usage Example: </p><div class="fragment"><div class="line">std::vector&lt;int&gt; input = {42, 42, 42, 42, 1337, 42};</div>
<div class="line">std::vector&lt;int&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input)</div>
<div class="line">    .skipWhile([](<span class="keyword">const</span> <span class="keywordtype">int</span> value) { <span class="keywordflow">return</span> (value == 42); }) <span class="comment">// skip leading 42s</span></div>
<div class="line">    .collect&lt;std::vector&gt;();</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l01749">1749</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>

</div>
</div>
<a id="af8c752a71a1a7931c711ed6749c62080" name="af8c752a71a1a7931c711ed6749c62080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8c752a71a1a7931c711ed6749c62080">&#9670;&nbsp;</a></span>sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="namespaceCXXIter.html#a36594d1d501e0f5fc7d80174fc82e42c">SortOrder</a> ORDER = SortOrder::ASCENDING, bool STABLE = false&gt; <br />
requires requires(const <a class="el" href="classCXXIter_1_1IterApi.html#a628012452f851b7099d919218e2a5512">ItemOwned</a>&amp; a) { { a &lt; a }; { a &gt; a }; }</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::sort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new iterator that takes the items from this iterator, and passes them on sorted. </p>
<dl class="section note"><dt>Note</dt><dd>This variant of <a class="el" href="classCXXIter_1_1IterApi.html#af8c752a71a1a7931c711ed6749c62080" title="Creates a new iterator that takes the items from this iterator, and passes them on sorted.">sort()</a> requires the items to support comparison operators. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>New iterator that returns the items of this iterator sorted. </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Sorter requires to first drain the input iterator, before being able to supply a single element. This leads to additional memory usage. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ORDER</td><td>Decides the sort order of the resulting iterator. </td></tr>
    <tr><td class="paramname">STABLE</td><td>If <code>true</code>, uses <code>std::stable_sort</code> internally, if <code>false</code> uses <code>std::sort</code> </td></tr>
  </table>
  </dd>
</dl>
<p>Usage Example:</p><ul>
<li>Sorting in ascending order using a custom comparer: <div class="fragment"><div class="line">std::vector&lt;float&gt; input = {1.0f, 2.0f, 0.5f, 3.0f, -42.0f};</div>
<div class="line">std::vector&lt;float&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input)</div>
<div class="line">    .sort&lt;CXXIter::ASCENDING, <span class="keyword">false</span>&gt;()</div>
<div class="line">    .collect&lt;std::vector&gt;();</div>
</div><!-- fragment --></li>
<li>Sorting in descending order using a custom comparer: <div class="fragment"><div class="line">std::vector&lt;float&gt; input = {1.0f, 2.0f, 0.5f, 3.0f, -42.0f};</div>
<div class="line">std::vector&lt;float&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input)</div>
<div class="line">    .sort&lt;CXXIter::DESCENDING, <span class="keyword">false</span>&gt;()</div>
<div class="line">    .collect&lt;std::vector&gt;();</div>
</div><!-- fragment --> </li>
</ul>

<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l02064">2064</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>

</div>
</div>
<a id="aff8dd89925c1e49327c408467ebdab22" name="aff8dd89925c1e49327c408467ebdab22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff8dd89925c1e49327c408467ebdab22">&#9670;&nbsp;</a></span>sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<div class="memtemplate">
template&lt;bool STABLE, std::invocable&lt; const <a class="el" href="classCXXIter_1_1IterApi.html#a628012452f851b7099d919218e2a5512">ItemOwned</a> &amp;, const <a class="el" href="classCXXIter_1_1IterApi.html#a628012452f851b7099d919218e2a5512">ItemOwned</a> &amp; &gt; TCompareFn&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::sort </td>
          <td>(</td>
          <td class="paramtype">TCompareFn&#160;</td>
          <td class="paramname"><em>compareFn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new iterator that takes the items from this iterator, and passes them on sorted, using the supplied <code>compareFn</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compareFn</td><td>Compare function used for the sorting of items. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New iterator that returns the items of this iterator sorted using the given <code>compareFn</code>. </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Sorter requires to first drain the input iterator, before being able to supply a single element. This leads to additional memory usage. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">STABLE</td><td>If <code>true</code>, uses <code>std::stable_sort</code> internally, if <code>false</code> uses <code>std::sort</code> </td></tr>
  </table>
  </dd>
</dl>
<p>Usage Example:</p><ul>
<li>Sorting in ascending order using a custom comparer: <div class="fragment"><div class="line">std::vector&lt;float&gt; input = {1.0f, 2.0f, 0.5f, 3.0f, -42.0f};</div>
<div class="line">std::vector&lt;float&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input)</div>
<div class="line">    .sort&lt;<span class="keyword">false</span>&gt;([](<span class="keyword">const</span> <span class="keywordtype">float</span>&amp; a, <span class="keyword">const</span> <span class="keywordtype">float</span>&amp; b) {</div>
<div class="line">        <span class="keywordflow">return</span> (a &lt; b);</div>
<div class="line">    })</div>
<div class="line">    .collect&lt;std::vector&gt;();</div>
</div><!-- fragment --></li>
<li>Sorting in descending order using a custom comparer: <div class="fragment"><div class="line">std::vector&lt;float&gt; input = {1.0f, 2.0f, 0.5f, 3.0f, -42.0f};</div>
<div class="line">std::vector&lt;float&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input)</div>
<div class="line">    .sort&lt;<span class="keyword">false</span>&gt;([](<span class="keyword">const</span> <span class="keywordtype">float</span>&amp; a, <span class="keyword">const</span> <span class="keywordtype">float</span>&amp; b) {</div>
<div class="line">        <span class="keywordflow">return</span> (a &gt; b);</div>
<div class="line">    })</div>
<div class="line">    .collect&lt;std::vector&gt;();</div>
</div><!-- fragment --> </li>
</ul>

<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l02033">2033</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>

</div>
</div>
<a id="afcf9678cee596627f5c9712a8efb7518" name="afcf9678cee596627f5c9712a8efb7518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcf9678cee596627f5c9712a8efb7518">&#9670;&nbsp;</a></span>sortBy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="namespaceCXXIter.html#a36594d1d501e0f5fc7d80174fc82e42c">SortOrder</a> ORDER = SortOrder::ASCENDING, bool STABLE = false, std::invocable&lt; const <a class="el" href="classCXXIter_1_1IterApi.html#a628012452f851b7099d919218e2a5512">ItemOwned</a> &amp; &gt; TSortValueExtractFn&gt; <br />
requires requires(const std::invoke_result_t&lt;TSortValueExtractFn, const <a class="el" href="classCXXIter_1_1IterApi.html#a628012452f851b7099d919218e2a5512">ItemOwned</a>&amp;&gt;&amp; a) { { a &lt; a }; { a &gt; a }; }</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::sortBy </td>
          <td>(</td>
          <td class="paramtype">TSortValueExtractFn&#160;</td>
          <td class="paramname"><em>sortValueExtractFn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new iterator that takes the items from this iterator, and passes them on sorted. </p>
<p >In comparison to <a class="el" href="classCXXIter_1_1IterApi.html#af8c752a71a1a7931c711ed6749c62080" title="Creates a new iterator that takes the items from this iterator, and passes them on sorted.">sort()</a>, which either uses a custom comparator or the items themselves for the sort operation, this variant takes a <code>sortValueExtractFn</code>, which extracts a value for each item in this iterator, that should be used for sorting comparisons. </p><dl class="section return"><dt>Returns</dt><dd>New iterator that returns the items of this iterator sorted. </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Sorter requires to first drain the input iterator, before being able to supply a single element. This leads to additional memory usage. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ORDER</td><td>Decides the sort order of the resulting iterator. </td></tr>
    <tr><td class="paramname">STABLE</td><td>If <code>true</code>, uses <code>std::stable_sort</code> internally, if <code>false</code> uses <code>std::sort</code> </td></tr>
  </table>
  </dd>
</dl>
<p>Usage Example:</p><ul>
<li>Sorting the items(strings) in ascending order of their length: <div class="fragment"><div class="line">std::vector&lt;std::string&gt; input = {<span class="stringliteral">&quot;test1&quot;</span>, <span class="stringliteral">&quot;test2&quot;</span>, <span class="stringliteral">&quot;test23&quot;</span>, <span class="stringliteral">&quot;test&quot;</span>, <span class="stringliteral">&quot;tes&quot;</span>};</div>
<div class="line">std::vector&lt;std::string&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input)</div>
<div class="line">    .sortBy&lt;CXXIter::ASCENDING, <span class="keyword">true</span>&gt;([](<span class="keyword">const</span> std::string&amp; item) { <span class="keywordflow">return</span> item.size(); })</div>
<div class="line">    .collect&lt;std::vector&gt;();</div>
</div><!-- fragment --></li>
<li>Sorting the items(strings) in descending order of their length: <div class="fragment"><div class="line">std::vector&lt;std::string&gt; input = {<span class="stringliteral">&quot;test1&quot;</span>, <span class="stringliteral">&quot;test2&quot;</span>, <span class="stringliteral">&quot;test23&quot;</span>, <span class="stringliteral">&quot;test&quot;</span>, <span class="stringliteral">&quot;tes&quot;</span>};</div>
<div class="line">std::vector&lt;std::string&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input)</div>
<div class="line">    .sortBy&lt;CXXIter::DESCENDING, <span class="keyword">true</span>&gt;([](<span class="keyword">const</span> std::string&amp; item) { <span class="keywordflow">return</span> item.size(); })</div>
<div class="line">    .collect&lt;std::vector&gt;();</div>
</div><!-- fragment --> </li>
</ul>

<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l02105">2105</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>

</div>
</div>
<a id="a83370ed3a2770da9e4b5aa7317534487" name="a83370ed3a2770da9e4b5aa7317534487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83370ed3a2770da9e4b5aa7317534487">&#9670;&nbsp;</a></span>stddev()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="namespaceCXXIter.html#a4e698a5b11eca24990a5db359a5e58ec">StatisticNormalization</a> NORM = StatisticNormalization::N, typename TResult  = ItemOwned, typename TCount  = ItemOwned&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; TResult &gt; <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::stddev </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Consumer that calculates the standard deviation of all elements of this iterator. </p>
<p >The standard deviation is calculated using </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classCXXIter_1_1IterApi.html#a5445e417abd242adfc7a3e378bcc9036" title="Consumer that calculates the variance of all elements of this iterator.">variance()</a>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This consumes the iterator. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The standard deviation of all elements of this iterator. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NORM</td><td>Type of the statistical normalization variant to use for the calculation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceCXXIter.html#a4e698a5b11eca24990a5db359a5e58ec" title="Normalization variant to use while calculating statistics (mean / stddev / ...)">StatisticNormalization</a> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TResult</td><td>Type of the stddev-calculation's result. This is also the type used for the sum of all elements. </td></tr>
    <tr><td class="paramname">TCount</td><td>Type the element counter is converted into, before dividing the sum and the squared sum by. This can be necessary, if TResult is a complex object that only supports the division operator for e.g. double.</td></tr>
  </table>
  </dd>
</dl>
<p>Usage Example:</p><ul>
<li>For iterators with at least 2 values: <div class="fragment"><div class="line">std::vector&lt;float&gt; input = {2.0f, 4.0f, 4.0f, 4.0f, 5.0f, 5.0f, 7.0f, 9.0f};</div>
<div class="line">std::optional&lt;float&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input).stddev();</div>
<div class="line"><span class="comment">// output == Some(2.0f)</span></div>
</div><!-- fragment --></li>
<li>For iterators with at least 2 values with (N-1) norm: <div class="fragment"><div class="line">std::vector&lt;float&gt; input = {1.0f, 2.0f, 3.0f};</div>
<div class="line">std::optional&lt;float&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input)</div>
<div class="line">   .stddev&lt;<a class="code hl_enumvalue" href="namespaceCXXIter.html#a4e698a5b11eca24990a5db359a5e58eca9c56dab0df559e59d13a9b7da360c7b8">CXXIter::StatisticNormalization::N_MINUS_ONE</a>&gt;();</div>
<div class="line"><span class="comment">// output == Some(1.0f)</span></div>
<div class="ttc" id="anamespaceCXXIter_html_a4e698a5b11eca24990a5db359a5e58eca9c56dab0df559e59d13a9b7da360c7b8"><div class="ttname"><a href="namespaceCXXIter.html#a4e698a5b11eca24990a5db359a5e58eca9c56dab0df559e59d13a9b7da360c7b8">CXXIter::StatisticNormalization::N_MINUS_ONE</a></div><div class="ttdeci">@ N_MINUS_ONE</div><div class="ttdoc">Use when the mean, variance, stddev is calculated from a sample of the population.</div></div>
</div><!-- fragment --></li>
<li>For iterators with less than 2 values (not defined): <div class="fragment"><div class="line">std::vector&lt;float&gt; input = {42.0f};</div>
<div class="line">std::optional&lt;float&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input).stddev();</div>
<div class="line"><span class="comment">// output == None</span></div>
</div><!-- fragment --> </li>
</ul>

<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l00898">898</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>

</div>
</div>
<a id="aa4cf427f53b7c5916727fe253589b817" name="aa4cf427f53b7c5916727fe253589b817"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4cf427f53b7c5916727fe253589b817">&#9670;&nbsp;</a></span>stepBy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::stepBy </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stepWidth</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an iterator with the requested <code>stepWidth</code> from this iterator. </p>
<p >A step width of <code>1</code> is a NO-OP, a step width of <code>2</code> means that every second element is skipped. The first element is always returned, irrespecting of the requested <code>stepWidth</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">step</td><td>Step width with which elements from this iterator are yielded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New iterator with the requested <code>stepWidth</code> </dd></dl>
<p>Usage Example:</p><ul>
<li>Step width of 1 (No-Op): <div class="fragment"><div class="line">   std::vector&lt;int&gt; input = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};</div>
<div class="line">   std::vector&lt;int&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input)</div>
<div class="line">           .stepBy(1)</div>
<div class="line">           .collect&lt;std::vector&gt;();</div>
<div class="line"><span class="comment">// output == {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}</span></div>
</div><!-- fragment --></li>
<li>Step width of 2: <div class="fragment"><div class="line">   std::vector&lt;int&gt; input = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};</div>
<div class="line">   std::vector&lt;int&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input)</div>
<div class="line">           .stepBy(2)</div>
<div class="line">           .collect&lt;std::vector&gt;();</div>
<div class="line"><span class="comment">// output == {0, 2, 4, 6, 8, 10}</span></div>
</div><!-- fragment --> </li>
</ul>

<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l01819">1819</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classCXXIter_1_1IterApi_aa4cf427f53b7c5916727fe253589b817_cgraph.svg" width="394" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ab5674bb7c86728cc2520d7b3bebea437" name="ab5674bb7c86728cc2520d7b3bebea437"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5674bb7c86728cc2520d7b3bebea437">&#9670;&nbsp;</a></span>stringJoin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::stringJoin </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>separator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Consumer that concatenates the elements of this iterator to a large <code>std::string</code> , where each element is separated by the specified <code>separator</code>. </p>
<dl class="section note"><dt>Note</dt><dd>This consumes the iterator. </dd>
<dd>
This method is only available for iterators whose elements are <code>std::string</code> . If that is not the case, convert your items to <code>std::string</code> s first, using a method like <code><a class="el" href="classCXXIter_1_1IterApi.html#ad8f3454d96494c248abf2e740442e6b6" title="Creates an iterator that uses the given mapFn to map each element from this iterator to elements of t...">map()</a></code>. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting string concatenation of all items of this iterator.</dd></dl>
<p>Usage Example:</p><ul>
<li>Non-empty iterator with default startValue <div class="fragment"><div class="line">std::vector&lt;int&gt; input = {42, 1337, 52};</div>
<div class="line"><span class="keywordtype">int</span> output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input).sum();</div>
<div class="line"><span class="comment">// output == 1431</span></div>
</div><!-- fragment --></li>
<li>Non-Empty iterator with custom startValue of 29906 <div class="fragment"><div class="line">std::vector&lt;int&gt; input = {42, 1337, 52};</div>
<div class="line"><span class="keywordtype">int</span> output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input).sum(29906);</div>
<div class="line"><span class="comment">// output == 31337</span></div>
</div><!-- fragment --></li>
<li>Empty iterator with default startValue <div class="fragment"><div class="line">std::vector&lt;int&gt; input = {};</div>
<div class="line"><span class="keywordtype">int</span> output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input).sum();</div>
<div class="line"><span class="comment">// output == 0</span></div>
</div><!-- fragment --></li>
<li>Empty iterator with custom startValue <div class="fragment"><div class="line">std::vector&lt;int&gt; input = {};</div>
<div class="line"><span class="keywordtype">int</span> output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input).sum(31337);</div>
<div class="line"><span class="comment">// output == 31337</span></div>
</div><!-- fragment --> </li>
</ul>

<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l00748">748</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classCXXIter_1_1IterApi_ab5674bb7c86728cc2520d7b3bebea437_cgraph.svg" width="635" height="60"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a69c182f266a918168975a3764a1fc8eb" name="a69c182f266a918168975a3764a1fc8eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69c182f266a918168975a3764a1fc8eb">&#9670;&nbsp;</a></span>sum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<div class="memtemplate">
template&lt;typename TResult  = ItemOwned&gt; <br />
requires requires(TResult res, <a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a> item) { { res += item }; }</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TResult <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::sum </td>
          <td>(</td>
          <td class="paramtype">TResult&#160;</td>
          <td class="paramname"><em>startValue</em> = <code>TResult()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Consumer that calculates the sum of all elements from this iterator. </p>
<dl class="section note"><dt>Note</dt><dd>This consumes the iterator. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startValue</td><td>Starting value from which to start the sum. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of all elements from this iterator, or <code>startValue</code> if this iterator had no elements.</dd></dl>
<p>Usage Example:</p><ul>
<li>Non-empty iterator with default startValue <div class="fragment"><div class="line">std::vector&lt;int&gt; input = {42, 1337, 52};</div>
<div class="line"><span class="keywordtype">int</span> output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input).sum();</div>
<div class="line"><span class="comment">// output == 1431</span></div>
</div><!-- fragment --></li>
<li>Non-Empty iterator with custom startValue of 29906 <div class="fragment"><div class="line">std::vector&lt;int&gt; input = {42, 1337, 52};</div>
<div class="line"><span class="keywordtype">int</span> output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input).sum(29906);</div>
<div class="line"><span class="comment">// output == 31337</span></div>
</div><!-- fragment --></li>
<li>Empty iterator with default startValue <div class="fragment"><div class="line">std::vector&lt;int&gt; input = {};</div>
<div class="line"><span class="keywordtype">int</span> output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input).sum();</div>
<div class="line"><span class="comment">// output == 0</span></div>
</div><!-- fragment --></li>
<li>Empty iterator with custom startValue <div class="fragment"><div class="line">std::vector&lt;int&gt; input = {};</div>
<div class="line"><span class="keywordtype">int</span> output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input).sum(31337);</div>
<div class="line"><span class="comment">// output == 31337</span></div>
</div><!-- fragment --> </li>
</ul>

<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l00710">710</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="classCXXIter_1_1IterApi_a69c182f266a918168975a3764a1fc8eb_cgraph.svg" width="100%" height="300"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>

</div>
</div>
<a id="a3e72f1bebe09215ce8effe156ca38d34" name="a3e72f1bebe09215ce8effe156ca38d34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e72f1bebe09215ce8effe156ca38d34">&#9670;&nbsp;</a></span>take()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">op::TakeN&lt; TSelf &gt; <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::take </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cnt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an iterator that yields at most the first <code>cnt</code> elements from this iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cnt</td><td>Amount of elements to yield from this iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new iterator that yields only at most the first <code>cnt</code> elements from this iterator.</dd></dl>
<p>Usage Example: </p><div class="fragment"><div class="line">std::vector&lt;int&gt; input = {42, 57, 64, 128, 1337, 10};</div>
<div class="line">std::vector&lt;int&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input)</div>
<div class="line">    .take(3) <span class="comment">// take first 3 values</span></div>
<div class="line">    .collect&lt;std::vector&gt;();</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l01766">1766</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>

</div>
</div>
<a id="ab16a10f60f2eddc85f29974d04672ba4" name="ab16a10f60f2eddc85f29974d04672ba4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab16a10f60f2eddc85f29974d04672ba4">&#9670;&nbsp;</a></span>takeWhile()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<div class="memtemplate">
template&lt;std::invocable&lt; const <a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a> &amp; &gt; TTakePredicate&gt; <br />
requires std::is_same_v&lt;std::invoke_result_t&lt;TTakePredicate, const <a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a>&amp;&gt;, bool&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::takeWhile </td>
          <td>(</td>
          <td class="paramtype">TTakePredicate&#160;</td>
          <td class="paramname"><em>takePredicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an iterator that yields the first elements of this iterator, for which the given <code>takePredicate</code> returns <code>true</code>. </p>
<p >The <code>takePredicate</code> is only called until it returned <code>false</code> for the first time, after that its job is done. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">takePredicate</td><td>Predicate that determines the items returned by the newly constructed iterator. After this predicate yielded <code>false</code> for the first time, the new iterator ends. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new iterator that yields the first couple elements from this iterator, until the given predicate returns <code>false</code> for the first time.</dd></dl>
<p>Usage Example: </p><div class="fragment"><div class="line">std::vector&lt;int&gt; input = {42, 57, 64, 128, 1337, 10};</div>
<div class="line">std::vector&lt;int&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input)</div>
<div class="line">    .takeWhile([](<span class="keyword">const</span> <span class="keywordtype">int</span> value) { <span class="keywordflow">return</span> (value &lt; 1000); }) <span class="comment">// take until first item &gt; 1000</span></div>
<div class="line">    .collect&lt;std::vector&gt;();</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l01790">1790</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>

</div>
</div>
<a id="a7c3a1a50ce87f94bbeb146897248e6f2" name="a7c3a1a50ce87f94bbeb146897248e6f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c3a1a50ce87f94bbeb146897248e6f2">&#9670;&nbsp;</a></span>unique() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::unique </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a new iterator that only contains every element of the input iterator only once. </p>
<p >This variant uses the input elements directly for the uniqueness-comparison. This requires the input elements to be hashable using <code>std::hash</code>. </p><dl class="section return"><dt>Returns</dt><dd>Iterator that does not contain duplicate elements from the input iterator's elements. </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Unique requires extra data storage to remember what items it has already seen. This leads to additional memory usage.</dd></dl>
<p>Usage Example: </p><div class="fragment"><div class="line">std::vector&lt;double&gt; input = {1.0, 1.0, 1.5, 1.4, 2.0, 2.1, 2.99, 3.25, 4.5};</div>
<div class="line">std::vector&lt;double&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input)</div>
<div class="line">       .unique()</div>
<div class="line">       .copied()</div>
<div class="line">       .collect&lt;std::vector&gt;();</div>
<div class="line"><span class="comment">// output == { 1.0, 1.5, 1.4, 2.0, 2.1, 2.99, 3.25, 4.5 }</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l01401">1401</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classCXXIter_1_1IterApi_a7c3a1a50ce87f94bbeb146897248e6f2_cgraph.svg" width="186" height="60"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ae692e23a444ce5a9f484ae959cd3bf7b" name="ae692e23a444ce5a9f484ae959cd3bf7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae692e23a444ce5a9f484ae959cd3bf7b">&#9670;&nbsp;</a></span>unique() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<div class="memtemplate">
template&lt;std::invocable&lt; const <a class="el" href="classCXXIter_1_1IterApi.html#a628012452f851b7099d919218e2a5512">ItemOwned</a> &amp; &gt; TMapFn&gt; <br />
requires util::is_hashable&lt;std::invoke_result_t&lt;TMapFn, const <a class="el" href="classCXXIter_1_1IterApi.html#a628012452f851b7099d919218e2a5512">ItemOwned</a>&amp;&gt;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">op::Unique&lt; TSelf, TMapFn &gt; <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::unique </td>
          <td>(</td>
          <td class="paramtype">TMapFn&#160;</td>
          <td class="paramname"><em>mapFn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a new iterator that only contains every element of the input iterator only once. </p>
<p >This variant checks whether the data returned by the given <code>mapFn</code> when invoked with the input's item is unique. This requires the data returned by <code>mapFn</code> to be hashable using <code>std::hash</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mapFn</td><td>Function that maps the input's element to data that should be used in the uniqueness-check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator that does not contain duplicate elements from the input iterator's elements. </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Unique requires extra data storage to remember what items it has already seen. This leads to additional memory usage.</dd></dl>
<p>Usage Example: </p><div class="fragment"><div class="line">std::vector&lt;double&gt; input = {1.0, 1.0, 1.5, 1.4, 2.0, 2.1, 2.99, 3.25, 4.5};</div>
<div class="line">std::vector&lt;double&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input)</div>
<div class="line">       .unique([](<span class="keywordtype">double</span> item) { <span class="keywordflow">return</span> std::floor(item); })</div>
<div class="line">       .<a class="code hl_function" href="classCXXIter_1_1IterApi.html#a116afb3640cb245742403c86fded359f">copied</a>()</div>
<div class="line">       .collect&lt;std::vector&gt;();</div>
<div class="line"><span class="comment">// output == { 1.0, 2.0, 3.25, 4.5 }</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l01379">1379</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>

</div>
</div>
<a id="a5445e417abd242adfc7a3e378bcc9036" name="a5445e417abd242adfc7a3e378bcc9036"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5445e417abd242adfc7a3e378bcc9036">&#9670;&nbsp;</a></span>variance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="namespaceCXXIter.html#a4e698a5b11eca24990a5db359a5e58ec">StatisticNormalization</a> NORM = StatisticNormalization::N, typename TResult  = ItemOwned, typename TCount  = ItemOwned&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; TResult &gt; <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::variance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Consumer that calculates the variance of all elements of this iterator. </p>
<p >The variance is calculated by incrementally calculating a sum and a squared sum of all elements. Then from there, the mean and then the variance are calculated. </p><dl class="section note"><dt>Note</dt><dd>This consumes the iterator. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The variance of all elements of this iterator. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NORM</td><td>Type of the statistical normalization variant to use for the calculation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceCXXIter.html#a4e698a5b11eca24990a5db359a5e58ec" title="Normalization variant to use while calculating statistics (mean / stddev / ...)">StatisticNormalization</a> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TResult</td><td>Type of the variance-calculation's result. This is also the type used for the sum of all elements. </td></tr>
    <tr><td class="paramname">TCount</td><td>Type the element counter is converted into, before dividing the sum and the squared sum by. This can be necessary, if TResult is a complex object that only supports the division operator for e.g. double. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance">https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance</a></dd></dl>
<p>Usage Example:</p><ul>
<li>For iterators with at least 2 values: <div class="fragment"><div class="line">std::vector&lt;float&gt; input = {2.0f, 4.0f, 4.0f, 4.0f, 5.0f, 5.0f, 7.0f, 9.0f};</div>
<div class="line">std::optional&lt;float&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input).variance();</div>
<div class="line"><span class="comment">// output == Some(4.0f)</span></div>
</div><!-- fragment --></li>
<li>For iterators with at least 2 values with (N-1) norm: <div class="fragment"><div class="line">std::vector&lt;float&gt; input = {1.0f, 2.0f, 3.0f};</div>
<div class="line">std::optional&lt;float&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input)</div>
<div class="line">   .variance&lt;<a class="code hl_enumvalue" href="namespaceCXXIter.html#a4e698a5b11eca24990a5db359a5e58eca9c56dab0df559e59d13a9b7da360c7b8">CXXIter::StatisticNormalization::N_MINUS_ONE</a>&gt;();</div>
<div class="line"><span class="comment">// output == Some(1.0f)</span></div>
</div><!-- fragment --></li>
<li>For iterators with less than 2 values (not defined): <div class="fragment"><div class="line">std::vector&lt;float&gt; input = {42.0f};</div>
<div class="line">std::optional&lt;float&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input).variance();</div>
<div class="line"><span class="comment">// output == None</span></div>
</div><!-- fragment --> </li>
</ul>

<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l00841">841</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="classCXXIter_1_1IterApi_a5445e417abd242adfc7a3e378bcc9036_cgraph.svg" width="100%" height="364"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>

</div>
</div>
<a id="a697a84ef397adc29008d87edbc7095fc" name="a697a84ef397adc29008d87edbc7095fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a697a84ef397adc29008d87edbc7095fc">&#9670;&nbsp;</a></span>zip()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<div class="memtemplate">
template&lt;typename TOtherIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">op::Zipper&lt; TSelf, std::pair, TOtherIterator &gt; <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::zip </td>
          <td>(</td>
          <td class="paramtype">TOtherIterator &amp;&amp;&#160;</td>
          <td class="paramname"><em>otherIterator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>"Zips up" two <a class="el" href="namespaceCXXIter.html" title="CXXIter.">CXXIter</a> iterators into a single iterator over pairs from both iterators. </p>
<p >Constructs new iterator that iterates over <code>std::pair&lt;&gt;</code> instances where values from this iterator are put in the first value, and values from the given <code>otherIterator</code> become the second values. The resulting iterator is only as long as the shorter of both zipped iterators. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">otherIterator</td><td>Second iterator zipped against this iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New iterator that zips together this iteratore and the given <code>otherIterator</code> into a new iterator over <code>std::pair&lt;&gt;</code> for both zipped iterator's values.</dd></dl>
<p>Usage Example: </p><div class="fragment"><div class="line">std::vector&lt;std::string&gt; input1 = {<span class="stringliteral">&quot;1337&quot;</span>, <span class="stringliteral">&quot;42&quot;</span>};</div>
<div class="line">std::vector&lt;int&gt; input2 = {1337, 42};</div>
<div class="line">std::vector&lt;std::pair&lt;std::string, int&gt;&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input1).copied()</div>
<div class="line">   .zip(<a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input2).<a class="code hl_function" href="classCXXIter_1_1IterApi.html#a116afb3640cb245742403c86fded359f">copied</a>())</div>
<div class="line">   .collect&lt;std::vector&gt;();</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l01846">1846</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>

</div>
</div>
<a id="a69a33172afd539a6dd763492752139c7" name="a69a33172afd539a6dd763492752139c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69a33172afd539a6dd763492752139c7">&#9670;&nbsp;</a></span>zipTuple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<div class="memtemplate">
template&lt;typename... TOtherIterators&gt; <br />
requires (CXXIterIterator&lt;TOtherIterators&gt; &amp;&amp; ...) &amp;&amp; (!std::disjunction_v&lt; std::is_reference&lt;typename <a class="el" href="structCXXIter_1_1trait_1_1Iterator.html">trait::Iterator</a>&lt;TOtherIterators&gt;<a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">::Item</a>&gt;... &gt; &amp;&amp; !IS_REFERENCE)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">op::Zipper&lt; TSelf, std::tuple, TOtherIterators... &gt; <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::zipTuple </td>
          <td>(</td>
          <td class="paramtype">TOtherIterators &amp;&amp;...&#160;</td>
          <td class="paramname"><em>otherIterators</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>"Zips up" an arbitrary amount of <a class="el" href="namespaceCXXIter.html" title="CXXIter.">CXXIter</a> iterators into a single iterator over <code>std::tuple&lt;&gt;</code> from both iterators. </p>
<p >Constructs new iterator that iterates over <code>std::tuple&lt;&gt;</code> instances where values from this iterator are put in the first value, and values from the given <code>otherIterators</code> are stored after that in order. The resulting iterator is only as long as the shortest of all iterators part of the zip. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">otherIterators</td><td>Other iterators zipped against this iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New iterator that zips together this iteratore and the given <code>otherIterators</code> into a new iterator over <code>std::tuple&lt;&gt;</code> for all of the zipped iterator's values.</dd></dl>
<p>Usage Example: </p><div class="fragment"><div class="line">   std::vector&lt;std::string&gt; input1 = {<span class="stringliteral">&quot;1337&quot;</span>, <span class="stringliteral">&quot;42&quot;</span>};</div>
<div class="line">   std::vector&lt;int&gt; input2 = {1337, 42, 80};</div>
<div class="line">   std::vector&lt;float&gt; input3 = {1337.0f, 42.0f, 64.0f};</div>
<div class="line">   std::vector&lt;std::tuple&lt;std::string, int, float&gt;&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input1).copied()</div>
<div class="line">           .zipTuple(<a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input2).<a class="code hl_function" href="classCXXIter_1_1IterApi.html#a116afb3640cb245742403c86fded359f">copied</a>(), <a class="code hl_function" href="namespaceCXXIter.html#a488278efdb3aea93ff9fa7583e3c81a8">CXXIter::from</a>(input3).<a class="code hl_function" href="classCXXIter_1_1IterApi.html#a116afb3640cb245742403c86fded359f">copied</a>())</div>
<div class="line">           .collect&lt;std::vector&gt;();</div>
<div class="line"><span class="comment">// output == { {&quot;1337&quot;, 1337, 1337.0f}, {&quot;42&quot;, 42, 42.0f} }</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l01873">1873</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/CXXIter/<a class="el" href="CXXIter_8h_source.html">CXXIter.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceCXXIter.html">CXXIter</a></li><li class="navelem"><a class="el" href="classCXXIter_1_1IterApi.html">IterApi</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
