<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CXXIter: CXXIter::IterApi&lt; TSelf &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CXXIter
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classCXXIter_1_1IterApi.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classCXXIter_1_1IterApi-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">CXXIter::IterApi&lt; TSelf &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Public Iterator API surface.  
 <a href="classCXXIter_1_1IterApi.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for CXXIter::IterApi&lt; TSelf &gt;:</div>
<div class="dyncontent">
<div class="center"><!-- SVG 0 -->
</div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a400f05b1c612d1088ce9561fd7191d32"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#a400f05b1c612d1088ce9561fd7191d32">Iterator</a> = IteratorTrait&lt; TSelf &gt;</td></tr>
<tr class="memdesc:a400f05b1c612d1088ce9561fd7191d32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the IteratorTrait implemenation for this.  <a href="classCXXIter_1_1IterApi.html#a400f05b1c612d1088ce9561fd7191d32">More...</a><br /></td></tr>
<tr class="separator:a400f05b1c612d1088ce9561fd7191d32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00f3ed5b2201522d327c6a8a92d371c8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a> = typename Iterator::Item</td></tr>
<tr class="memdesc:a00f3ed5b2201522d327c6a8a92d371c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the elements of this iterator. (Can be references)  <a href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">More...</a><br /></td></tr>
<tr class="separator:a00f3ed5b2201522d327c6a8a92d371c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8242394d80dd375319dda6bc0872d07d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#a8242394d80dd375319dda6bc0872d07d">ItemOwned</a> = typename std::remove_reference&lt; <a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a> &gt;::type</td></tr>
<tr class="memdesc:a8242394d80dd375319dda6bc0872d07d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Owned Type of the elements of this iterator. (References removed).  <a href="classCXXIter_1_1IterApi.html#a8242394d80dd375319dda6bc0872d07d">More...</a><br /></td></tr>
<tr class="separator:a8242394d80dd375319dda6bc0872d07d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9baddc40de1b9c63102e5c5bf886474e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCXXIter_1_1SizeHint.html">SizeHint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#a9baddc40de1b9c63102e5c5bf886474e">sizeHint</a> () const</td></tr>
<tr class="separator:a9baddc40de1b9c63102e5c5bf886474e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad1cbb262290264fc2e12d80492ad066"><td class="memTemplParams" colspan="2">template&lt;typename TUseFn &gt; </td></tr>
<tr class="memitem:aad1cbb262290264fc2e12d80492ad066"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#aad1cbb262290264fc2e12d80492ad066">forEach</a> (TUseFn useFn)</td></tr>
<tr class="memdesc:aad1cbb262290264fc2e12d80492ad066"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consumer that calls the given function <code>useFn</code> for each of the elements in this iterator.  <a href="classCXXIter_1_1IterApi.html#aad1cbb262290264fc2e12d80492ad066">More...</a><br /></td></tr>
<tr class="separator:aad1cbb262290264fc2e12d80492ad066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a294c5e7bc59f4e4c5d7e40b96dff3a89"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename... &gt; typename TTargetContainer, typename... TTargetContainerArgs&gt; </td></tr>
<tr class="memitem:a294c5e7bc59f4e4c5d7e40b96dff3a89"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#a294c5e7bc59f4e4c5d7e40b96dff3a89">collect</a> ()</td></tr>
<tr class="memdesc:a294c5e7bc59f4e4c5d7e40b96dff3a89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consumer that collects all elements from this iterator in a new container of type <code>TTargetContainer</code>.  <a href="classCXXIter_1_1IterApi.html#a294c5e7bc59f4e4c5d7e40b96dff3a89">More...</a><br /></td></tr>
<tr class="separator:a294c5e7bc59f4e4c5d7e40b96dff3a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16bc04471483e7ce71726036befa551e"><td class="memTemplParams" colspan="2">template&lt;typename TResult , std::invocable&lt; TResult &amp;, <a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a> &amp;&amp; &gt; FoldFn&gt; </td></tr>
<tr class="memitem:a16bc04471483e7ce71726036befa551e"><td class="memTemplItemLeft" align="right" valign="top">TResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#a16bc04471483e7ce71726036befa551e">fold</a> (TResult startValue, FoldFn foldFn)</td></tr>
<tr class="memdesc:a16bc04471483e7ce71726036befa551e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consumer that executes the given <code>foldFn</code> for each item in this iterator, to apply to a working value, which is passed on and passed as second argument to the next call to <code>foldFn</code>.  <a href="classCXXIter_1_1IterApi.html#a16bc04471483e7ce71726036befa551e">More...</a><br /></td></tr>
<tr class="separator:a16bc04471483e7ce71726036befa551e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a418901ce726860a7a91bffbc210c1815"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#a418901ce726860a7a91bffbc210c1815">count</a> ()</td></tr>
<tr class="memdesc:a418901ce726860a7a91bffbc210c1815"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consumer that counts the elements in this iterator.  <a href="classCXXIter_1_1IterApi.html#a418901ce726860a7a91bffbc210c1815">More...</a><br /></td></tr>
<tr class="separator:a418901ce726860a7a91bffbc210c1815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69c182f266a918168975a3764a1fc8eb"><td class="memTemplParams" colspan="2">template&lt;typename TResult  = ItemOwned&gt; <br />
requires requires(TResult res, <a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a> item) { { res += item }; }</td></tr>
<tr class="memitem:a69c182f266a918168975a3764a1fc8eb"><td class="memTemplItemLeft" align="right" valign="top">TResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#a69c182f266a918168975a3764a1fc8eb">sum</a> (TResult startValue=TResult())</td></tr>
<tr class="memdesc:a69c182f266a918168975a3764a1fc8eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consumer that calculates the sum of all elements from this iterator.  <a href="classCXXIter_1_1IterApi.html#a69c182f266a918168975a3764a1fc8eb">More...</a><br /></td></tr>
<tr class="separator:a69c182f266a918168975a3764a1fc8eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5674bb7c86728cc2520d7b3bebea437"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#ab5674bb7c86728cc2520d7b3bebea437">stringJoin</a> (const std::string &amp;separator)</td></tr>
<tr class="memdesc:ab5674bb7c86728cc2520d7b3bebea437"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consumer that concatenates the elements of this iterator to a large <code>std::string</code> , where each element is separated by the specified <code>separator</code>.  <a href="classCXXIter_1_1IterApi.html#ab5674bb7c86728cc2520d7b3bebea437">More...</a><br /></td></tr>
<tr class="separator:ab5674bb7c86728cc2520d7b3bebea437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab96a0fdc7efba2f4bddfa013429bc6bc"><td class="memTemplParams" colspan="2">template&lt;typename TResult  = ItemOwned, typename TCount  = ItemOwned&gt; </td></tr>
<tr class="memitem:ab96a0fdc7efba2f4bddfa013429bc6bc"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; TResult &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#ab96a0fdc7efba2f4bddfa013429bc6bc">mean</a> ()</td></tr>
<tr class="memdesc:ab96a0fdc7efba2f4bddfa013429bc6bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consumer that calculates the mean of all elements of this iterator.  <a href="classCXXIter_1_1IterApi.html#ab96a0fdc7efba2f4bddfa013429bc6bc">More...</a><br /></td></tr>
<tr class="separator:ab96a0fdc7efba2f4bddfa013429bc6bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f98bcc96bc3b93477045dabc085c733"><td class="memTemplParams" colspan="2">template&lt;typename TResult  = ItemOwned&gt; <br />
requires requires(TResult res, <a class="el" href="classCXXIter_1_1IterApi.html#a8242394d80dd375319dda6bc0872d07d">ItemOwned</a> item) { { item &lt; res }; { res = item }; }</td></tr>
<tr class="memitem:a9f98bcc96bc3b93477045dabc085c733"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; TResult &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#a9f98bcc96bc3b93477045dabc085c733">min</a> ()</td></tr>
<tr class="memdesc:a9f98bcc96bc3b93477045dabc085c733"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consumer that yields the smallest element from this iterator.  <a href="classCXXIter_1_1IterApi.html#a9f98bcc96bc3b93477045dabc085c733">More...</a><br /></td></tr>
<tr class="separator:a9f98bcc96bc3b93477045dabc085c733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7704878b20d80e80a913911314e095b1"><td class="memTemplParams" colspan="2">template&lt;typename TResult  = ItemOwned&gt; <br />
requires requires(TResult res, <a class="el" href="classCXXIter_1_1IterApi.html#a8242394d80dd375319dda6bc0872d07d">ItemOwned</a> item) { { item &gt; res }; { res = item }; }</td></tr>
<tr class="memitem:a7704878b20d80e80a913911314e095b1"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; TResult &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#a7704878b20d80e80a913911314e095b1">max</a> ()</td></tr>
<tr class="memdesc:a7704878b20d80e80a913911314e095b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consumer that yields the largest element from this iterator.  <a href="classCXXIter_1_1IterApi.html#a7704878b20d80e80a913911314e095b1">More...</a><br /></td></tr>
<tr class="separator:a7704878b20d80e80a913911314e095b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af11b6d97680a8e6a080261b51ff67fe6"><td class="memTemplParams" colspan="2">template&lt;typename TMinValueExtractFn &gt; <br />
requires requires(const std::invoke_result_t&lt;TMinValueExtractFn, const <a class="el" href="classCXXIter_1_1IterApi.html#a8242394d80dd375319dda6bc0872d07d">ItemOwned</a>&amp;&gt;&amp; a) { { a &lt; a }; }</td></tr>
<tr class="memitem:af11b6d97680a8e6a080261b51ff67fe6"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classCXXIter_1_1IterApi.html#a8242394d80dd375319dda6bc0872d07d">ItemOwned</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#af11b6d97680a8e6a080261b51ff67fe6">minBy</a> (TMinValueExtractFn minValueExtractFn)</td></tr>
<tr class="memdesc:af11b6d97680a8e6a080261b51ff67fe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consumer that yields the smallest element from this iterator. Comparison of items is done using the comparison values returned by invoking the given <code>minValueExtractFn</code> on each element.  <a href="classCXXIter_1_1IterApi.html#af11b6d97680a8e6a080261b51ff67fe6">More...</a><br /></td></tr>
<tr class="separator:af11b6d97680a8e6a080261b51ff67fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a793d9ebfadf1f1266605bff81b98fd33"><td class="memTemplParams" colspan="2">template&lt;typename TMaxValueExtractFn &gt; <br />
requires requires(const std::invoke_result_t&lt;TMaxValueExtractFn, const <a class="el" href="classCXXIter_1_1IterApi.html#a8242394d80dd375319dda6bc0872d07d">ItemOwned</a>&amp;&gt;&amp; a) { { a &gt; a }; }</td></tr>
<tr class="memitem:a793d9ebfadf1f1266605bff81b98fd33"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classCXXIter_1_1IterApi.html#a8242394d80dd375319dda6bc0872d07d">ItemOwned</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#a793d9ebfadf1f1266605bff81b98fd33">maxBy</a> (TMaxValueExtractFn minValueExtractFn)</td></tr>
<tr class="memdesc:a793d9ebfadf1f1266605bff81b98fd33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consumer that yields the largest element from this iterator. Comparison of items is done using the comparison values returned by invoking the given <code>minValueExtractFn</code> on each element.  <a href="classCXXIter_1_1IterApi.html#a793d9ebfadf1f1266605bff81b98fd33">More...</a><br /></td></tr>
<tr class="separator:a793d9ebfadf1f1266605bff81b98fd33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44b0b9e08a32e3f1003857ece564fb82"><td class="memTemplParams" colspan="2">template&lt;typename _unused  = ItemOwned&gt; </td></tr>
<tr class="memitem:a44b0b9e08a32e3f1003857ece564fb82"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classCXXIter_1_1IterApi.html#a8242394d80dd375319dda6bc0872d07d">ItemOwned</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#a44b0b9e08a32e3f1003857ece564fb82">last</a> ()</td></tr>
<tr class="memdesc:a44b0b9e08a32e3f1003857ece564fb82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consumer that yields the last element of this iterator.  <a href="classCXXIter_1_1IterApi.html#a44b0b9e08a32e3f1003857ece564fb82">More...</a><br /></td></tr>
<tr class="separator:a44b0b9e08a32e3f1003857ece564fb82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a054a041fb9dbbecc46138a09e08313e7"><td class="memTemplParams" colspan="2">template&lt;typename TItemOutput &gt; </td></tr>
<tr class="memitem:a054a041fb9dbbecc46138a09e08313e7"><td class="memTemplItemLeft" align="right" valign="top">Caster&lt; TSelf, TItemOutput &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#a054a041fb9dbbecc46138a09e08313e7">cast</a> ()</td></tr>
<tr class="memdesc:a054a041fb9dbbecc46138a09e08313e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new iterator that casts the elements of this iterator to the type requested by <code>TItemOutput</code>.  <a href="classCXXIter_1_1IterApi.html#a054a041fb9dbbecc46138a09e08313e7">More...</a><br /></td></tr>
<tr class="separator:a054a041fb9dbbecc46138a09e08313e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a116afb3640cb245742403c86fded359f"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#a116afb3640cb245742403c86fded359f">copied</a> ()</td></tr>
<tr class="memdesc:a116afb3640cb245742403c86fded359f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new iterator that copies the elements of this iterator.  <a href="classCXXIter_1_1IterApi.html#a116afb3640cb245742403c86fded359f">More...</a><br /></td></tr>
<tr class="separator:a116afb3640cb245742403c86fded359f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7218d94c0c1e6c45dc36abccd57829db"><td class="memTemplParams" colspan="2">template&lt;std::invocable&lt; const <a class="el" href="classCXXIter_1_1IterApi.html#a8242394d80dd375319dda6bc0872d07d">ItemOwned</a> &amp; &gt; TFilterFn&gt; </td></tr>
<tr class="memitem:a7218d94c0c1e6c45dc36abccd57829db"><td class="memTemplItemLeft" align="right" valign="top">Filter&lt; TSelf, TFilterFn &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#a7218d94c0c1e6c45dc36abccd57829db">filter</a> (TFilterFn filterFn)</td></tr>
<tr class="memdesc:a7218d94c0c1e6c45dc36abccd57829db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new iterator that only contains the elements from this iterator, for which the given <code>filterFn</code> returned <code>true</code>.  <a href="classCXXIter_1_1IterApi.html#a7218d94c0c1e6c45dc36abccd57829db">More...</a><br /></td></tr>
<tr class="separator:a7218d94c0c1e6c45dc36abccd57829db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8f3454d96494c248abf2e740442e6b6"><td class="memTemplParams" colspan="2">template&lt;std::invocable&lt; <a class="el" href="classCXXIter_1_1IterApi.html#a8242394d80dd375319dda6bc0872d07d">ItemOwned</a> &amp;&amp; &gt; TMapFn&gt; </td></tr>
<tr class="memitem:ad8f3454d96494c248abf2e740442e6b6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#ad8f3454d96494c248abf2e740442e6b6">map</a> (TMapFn mapFn)</td></tr>
<tr class="memdesc:ad8f3454d96494c248abf2e740442e6b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an iterator that uses the given <code>mapFn</code> to map each element from this iterator to elements of the new iterator.  <a href="classCXXIter_1_1IterApi.html#ad8f3454d96494c248abf2e740442e6b6">More...</a><br /></td></tr>
<tr class="separator:ad8f3454d96494c248abf2e740442e6b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a165695af4dc2acf1cf6eadd3ae6c2fc2"><td class="memTemplParams" colspan="2">template&lt;std::invocable&lt; <a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a> &amp;&amp; &gt; TFlatMapFn&gt; </td></tr>
<tr class="memitem:a165695af4dc2acf1cf6eadd3ae6c2fc2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#a165695af4dc2acf1cf6eadd3ae6c2fc2">flatMap</a> (TFlatMapFn mapFn)</td></tr>
<tr class="memdesc:a165695af4dc2acf1cf6eadd3ae6c2fc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an iterator that works like <a class="el" href="classCXXIter_1_1IterApi.html#ad8f3454d96494c248abf2e740442e6b6" title="Creates an iterator that uses the given mapFn to map each element from this iterator to elements of t...">map()</a>, but flattens nested containers.  <a href="classCXXIter_1_1IterApi.html#a165695af4dc2acf1cf6eadd3ae6c2fc2">More...</a><br /></td></tr>
<tr class="separator:a165695af4dc2acf1cf6eadd3ae6c2fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8985f7682655e5a925329fcd971b482"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#ad8985f7682655e5a925329fcd971b482">flatMap</a> ()</td></tr>
<tr class="memdesc:ad8985f7682655e5a925329fcd971b482"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an iterator that flattens the iterable elements of this iterator.  <a href="classCXXIter_1_1IterApi.html#ad8985f7682655e5a925329fcd971b482">More...</a><br /></td></tr>
<tr class="separator:ad8985f7682655e5a925329fcd971b482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48bef0687a6d677acbfa59d6a49b17c3"><td class="memTemplParams" colspan="2">template&lt;std::invocable&lt; <a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a> &amp; &gt; TModifierFn&gt; </td></tr>
<tr class="memitem:a48bef0687a6d677acbfa59d6a49b17c3"><td class="memTemplItemLeft" align="right" valign="top">InplaceModifier&lt; TSelf, TModifierFn &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#a48bef0687a6d677acbfa59d6a49b17c3">modify</a> (TModifierFn modifierFn)</td></tr>
<tr class="memdesc:a48bef0687a6d677acbfa59d6a49b17c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to inspect and modify each item in-place, that passes through this iterator.  <a href="classCXXIter_1_1IterApi.html#a48bef0687a6d677acbfa59d6a49b17c3">More...</a><br /></td></tr>
<tr class="separator:a48bef0687a6d677acbfa59d6a49b17c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a009154287504a68df72425093ee90851"><td class="memTemplParams" colspan="2">template&lt;std::invocable&lt; <a class="el" href="classCXXIter_1_1IterApi.html#a8242394d80dd375319dda6bc0872d07d">ItemOwned</a> &amp;&amp; &gt; TFilterMapFn&gt; <br />
requires is_optional&lt;std::invoke_result_t&lt;TFilterMapFn, <a class="el" href="classCXXIter_1_1IterApi.html#a8242394d80dd375319dda6bc0872d07d">ItemOwned</a>&amp;&amp;&gt;&gt;</td></tr>
<tr class="memitem:a009154287504a68df72425093ee90851"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#a009154287504a68df72425093ee90851">filterMap</a> (TFilterMapFn filterMapFn)</td></tr>
<tr class="memdesc:a009154287504a68df72425093ee90851"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new iterator that filters and maps items from this iterator.  <a href="classCXXIter_1_1IterApi.html#a009154287504a68df72425093ee90851">More...</a><br /></td></tr>
<tr class="separator:a009154287504a68df72425093ee90851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad616d50fe5b01eb2fdbfe02ced9cc2a1"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#ad616d50fe5b01eb2fdbfe02ced9cc2a1">skip</a> (size_t cnt)</td></tr>
<tr class="memdesc:ad616d50fe5b01eb2fdbfe02ced9cc2a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an iterator that skips the first <code>cnt</code> elements from this iterator, before it yields the remaining items.  <a href="classCXXIter_1_1IterApi.html#ad616d50fe5b01eb2fdbfe02ced9cc2a1">More...</a><br /></td></tr>
<tr class="separator:ad616d50fe5b01eb2fdbfe02ced9cc2a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a6a0f58078b8797c3ede1e6ec3896ce"><td class="memTemplParams" colspan="2">template&lt;std::invocable&lt; const <a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a> &amp; &gt; TSkipPredicate&gt; </td></tr>
<tr class="memitem:a2a6a0f58078b8797c3ede1e6ec3896ce"><td class="memTemplItemLeft" align="right" valign="top">SkipWhile&lt; TSelf, TSkipPredicate &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#a2a6a0f58078b8797c3ede1e6ec3896ce">skipWhile</a> (TSkipPredicate skipPredicate)</td></tr>
<tr class="memdesc:a2a6a0f58078b8797c3ede1e6ec3896ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an iterator that skips the first elements of this iterator, for which the given <code>skipPredicate</code> returns <code>true</code>.  <a href="classCXXIter_1_1IterApi.html#a2a6a0f58078b8797c3ede1e6ec3896ce">More...</a><br /></td></tr>
<tr class="separator:a2a6a0f58078b8797c3ede1e6ec3896ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36ee6ce2e84839b2e353bb83b07a64c2"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#a36ee6ce2e84839b2e353bb83b07a64c2">take</a> (size_t cnt)</td></tr>
<tr class="memdesc:a36ee6ce2e84839b2e353bb83b07a64c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an iterator that yields at most the first <code>cnt</code> elements from this iterator.  <a href="classCXXIter_1_1IterApi.html#a36ee6ce2e84839b2e353bb83b07a64c2">More...</a><br /></td></tr>
<tr class="separator:a36ee6ce2e84839b2e353bb83b07a64c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab16a10f60f2eddc85f29974d04672ba4"><td class="memTemplParams" colspan="2">template&lt;std::invocable&lt; const <a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a> &amp; &gt; TTakePredicate&gt; <br />
requires std::is_same_v&lt;std::invoke_result_t&lt;TTakePredicate, const <a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a>&amp;&gt;, bool&gt;</td></tr>
<tr class="memitem:ab16a10f60f2eddc85f29974d04672ba4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#ab16a10f60f2eddc85f29974d04672ba4">takeWhile</a> (TTakePredicate takePredicate)</td></tr>
<tr class="memdesc:ab16a10f60f2eddc85f29974d04672ba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an iterator that yields the first elements of this iterator, for which the given <code>takePredicate</code> returns <code>true</code>.  <a href="classCXXIter_1_1IterApi.html#ab16a10f60f2eddc85f29974d04672ba4">More...</a><br /></td></tr>
<tr class="separator:ab16a10f60f2eddc85f29974d04672ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae49eef0f6493a206d6db38c05e36dbed"><td class="memTemplParams" colspan="2">template&lt;typename TOtherIterator &gt; <br />
requires (!std::is_reference_v&lt;typename IteratorTrait&lt;TOtherIterator&gt;<a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">::Item</a>&gt; &amp;&amp; !IS_REFERENCE)</td></tr>
<tr class="memitem:ae49eef0f6493a206d6db38c05e36dbed"><td class="memTemplItemLeft" align="right" valign="top">Zipper&lt; TSelf, TOtherIterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#ae49eef0f6493a206d6db38c05e36dbed">zip</a> (TOtherIterator &amp;&amp;otherIterator)</td></tr>
<tr class="memdesc:ae49eef0f6493a206d6db38c05e36dbed"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Zips up" two <a class="el" href="namespaceCXXIter.html" title="CXXIter.">CXXIter</a> iterators into a single iterator over pairs from both iterators.  <a href="classCXXIter_1_1IterApi.html#ae49eef0f6493a206d6db38c05e36dbed">More...</a><br /></td></tr>
<tr class="separator:ae49eef0f6493a206d6db38c05e36dbed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3da71f522eb2a4e2177c9edb3bc713d5"><td class="memTemplParams" colspan="2">template&lt;std::invocable&lt; const <a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a> &amp; &gt; TGroupIdentifierFn&gt; </td></tr>
<tr class="memitem:a3da71f522eb2a4e2177c9edb3bc713d5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#a3da71f522eb2a4e2177c9edb3bc713d5">groupBy</a> (TGroupIdentifierFn groupIdentFn)</td></tr>
<tr class="memdesc:a3da71f522eb2a4e2177c9edb3bc713d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Groups the elements of this iterator according to the values returned by the given <code>groupidentFn</code>.  <a href="classCXXIter_1_1IterApi.html#a3da71f522eb2a4e2177c9edb3bc713d5">More...</a><br /></td></tr>
<tr class="separator:a3da71f522eb2a4e2177c9edb3bc713d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25568f12125a97a9579508a5cf5e7bd6"><td class="memTemplParams" colspan="2">template&lt;bool STABLE, std::invocable&lt; const <a class="el" href="classCXXIter_1_1IterApi.html#a8242394d80dd375319dda6bc0872d07d">ItemOwned</a> &amp;, const <a class="el" href="classCXXIter_1_1IterApi.html#a8242394d80dd375319dda6bc0872d07d">ItemOwned</a> &amp; &gt; TCompareFn&gt; </td></tr>
<tr class="memitem:a25568f12125a97a9579508a5cf5e7bd6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#a25568f12125a97a9579508a5cf5e7bd6">sorted</a> (TCompareFn compareFn)</td></tr>
<tr class="memdesc:a25568f12125a97a9579508a5cf5e7bd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new iterator that takes the items from this iterator, and passes them on sorted, using the supplied <code>compareFn</code>.  <a href="classCXXIter_1_1IterApi.html#a25568f12125a97a9579508a5cf5e7bd6">More...</a><br /></td></tr>
<tr class="separator:a25568f12125a97a9579508a5cf5e7bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c92644bc9fdae0fdc0795e0cfbda883"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceCXXIter.html#a36594d1d501e0f5fc7d80174fc82e42c">SortOrder</a> ORDER = SortOrder::ASCENDING, bool STABLE = false&gt; <br />
requires requires(const <a class="el" href="classCXXIter_1_1IterApi.html#a8242394d80dd375319dda6bc0872d07d">ItemOwned</a>&amp; a) { { a &lt; a }; { a &gt; a }; }</td></tr>
<tr class="memitem:a6c92644bc9fdae0fdc0795e0cfbda883"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#a6c92644bc9fdae0fdc0795e0cfbda883">sorted</a> ()</td></tr>
<tr class="memdesc:a6c92644bc9fdae0fdc0795e0cfbda883"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new iterator that takes the items from this iterator, and passes them on sorted.  <a href="classCXXIter_1_1IterApi.html#a6c92644bc9fdae0fdc0795e0cfbda883">More...</a><br /></td></tr>
<tr class="separator:a6c92644bc9fdae0fdc0795e0cfbda883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90fcf438abe534c819b846b6a3fbf8c1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceCXXIter.html#a36594d1d501e0f5fc7d80174fc82e42c">SortOrder</a> ORDER = SortOrder::ASCENDING, bool STABLE = false, std::invocable&lt; const <a class="el" href="classCXXIter_1_1IterApi.html#a8242394d80dd375319dda6bc0872d07d">ItemOwned</a> &amp; &gt; TSortValueExtractFn&gt; <br />
requires requires(const std::invoke_result_t&lt;TSortValueExtractFn, const <a class="el" href="classCXXIter_1_1IterApi.html#a8242394d80dd375319dda6bc0872d07d">ItemOwned</a>&amp;&gt;&amp; a) { { a &lt; a }; { a &gt; a }; }</td></tr>
<tr class="memitem:a90fcf438abe534c819b846b6a3fbf8c1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCXXIter_1_1IterApi.html#a90fcf438abe534c819b846b6a3fbf8c1">sortedBy</a> (TSortValueExtractFn sortValueExtractFn)</td></tr>
<tr class="memdesc:a90fcf438abe534c819b846b6a3fbf8c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new iterator that takes the items from this iterator, and passes them on sorted.  <a href="classCXXIter_1_1IterApi.html#a90fcf438abe534c819b846b6a3fbf8c1">More...</a><br /></td></tr>
<tr class="separator:a90fcf438abe534c819b846b6a3fbf8c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;CXXIterIterator TSelf&gt;<br />
class CXXIter::IterApi&lt; TSelf &gt;</div><p >Public Iterator API surface. </p>

<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l01069">1069</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a00f3ed5b2201522d327c6a8a92d371c8" name="a00f3ed5b2201522d327c6a8a92d371c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00f3ed5b2201522d327c6a8a92d371c8">&#9670;&nbsp;</a></span>Item</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::Item =  typename Iterator::Item</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of the elements of this iterator. (Can be references) </p>

<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l01078">1078</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>

</div>
</div>
<a id="a8242394d80dd375319dda6bc0872d07d" name="a8242394d80dd375319dda6bc0872d07d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8242394d80dd375319dda6bc0872d07d">&#9670;&nbsp;</a></span>ItemOwned</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::ItemOwned =  typename std::remove_reference&lt;<a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a>&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Owned Type of the elements of this iterator. (References removed). </p>

<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l01082">1082</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>

</div>
</div>
<a id="a400f05b1c612d1088ce9561fd7191d32" name="a400f05b1c612d1088ce9561fd7191d32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a400f05b1c612d1088ce9561fd7191d32">&#9670;&nbsp;</a></span>Iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::Iterator =  IteratorTrait&lt;TSelf&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of the IteratorTrait implemenation for this. </p>

<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l01074">1074</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae0545d71c1c8f38bd42e712c3a2e1e96" name="ae0545d71c1c8f38bd42e712c3a2e1e96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0545d71c1c8f38bd42e712c3a2e1e96">&#9670;&nbsp;</a></span>~IterApi()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::~<a class="el" href="classCXXIter_1_1IterApi.html">IterApi</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l01090">1090</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a054a041fb9dbbecc46138a09e08313e7" name="a054a041fb9dbbecc46138a09e08313e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a054a041fb9dbbecc46138a09e08313e7">&#9670;&nbsp;</a></span>cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<div class="memtemplate">
template&lt;typename TItemOutput &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Caster&lt; TSelf, TItemOutput &gt; <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::cast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a new iterator that casts the elements of this iterator to the type requested by <code>TItemOutput</code>. </p>
<p >This iterator applies the requested type cast to <code>TItemOutput</code> using <code>static_cast&lt;&gt;</code>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TItemOutput</td><td>Type to cast the elements of this iterator to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new iterator that casts all elements from this iterator to the requested type <code>TItemOutput</code>.</dd></dl>
<p>Usage Example: </p><div class="fragment"><div class="line">std::vector&lt;float&gt; input = {1.35, 56.123};</div>
<div class="line">std::vector&lt;double&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#af434a00cfbd2627ea113f6b9286b378f">CXXIter::from</a>(input)</div>
<div class="line">        .cast&lt;<span class="keywordtype">double</span>&gt;()</div>
<div class="line">        .collect&lt;std::vector&gt;();</div>
<div class="ttc" id="anamespaceCXXIter_html_af434a00cfbd2627ea113f6b9286b378f"><div class="ttname"><a href="namespaceCXXIter.html#af434a00cfbd2627ea113f6b9286b378f">CXXIter::from</a></div><div class="ttdeci">SrcMov&lt; owned_t&lt; TContainer &gt; &gt; from(TContainer &amp;&amp;container)</div><div class="ttdoc">Construct a CXXIter move source from the given container.</div><div class="ttdef"><b>Definition:</b> <a href="CXXIter_8h_source.html#l01950">CXXIter.h:1950</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l01513">1513</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>

</div>
</div>
<a id="a294c5e7bc59f4e4c5d7e40b96dff3a89" name="a294c5e7bc59f4e4c5d7e40b96dff3a89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a294c5e7bc59f4e4c5d7e40b96dff3a89">&#9670;&nbsp;</a></span>collect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<div class="memtemplate">
template&lt;template&lt; typename... &gt; typename TTargetContainer, typename... TTargetContainerArgs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::collect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Consumer that collects all elements from this iterator in a new container of type <code>TTargetContainer</code>. </p>
<dl class="section note"><dt>Note</dt><dd>This consumes the iterator. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TTargetContainer</td><td>Type-Template for the target container that the elements from this iterator should be collected into. The first template parameter of this Type-Template has to take the type of the elements. </td></tr>
    <tr><td class="paramname">TTargetContainerArgs...</td><td>Optional additional type attributes to pass on to the target container. These are appended to the item value type, which is automatically supplied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An instance of <code>TTargetContainer</code> with all the elements of this iterator collected into.</dd></dl>
<p>Usage Example: </p><div class="fragment"><div class="line">std::vector&lt;std::string&gt; input = {<span class="stringliteral">&quot;1337&quot;</span>, <span class="stringliteral">&quot;42&quot;</span>, <span class="stringliteral">&quot;64&quot;</span>};</div>
<div class="line">std::vector&lt;std::string&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#af434a00cfbd2627ea113f6b9286b378f">CXXIter::from</a>(input)</div>
<div class="line">    .collect&lt;std::vector&gt;();</div>
</div><!-- fragment --><p >With Additional container type parameters: </p><div class="fragment"><div class="line">std::vector&lt;std::string&gt; input = {<span class="stringliteral">&quot;1337&quot;</span>, <span class="stringliteral">&quot;42&quot;</span>, <span class="stringliteral">&quot;64&quot;</span>};</div>
<div class="line">std::vector&lt;std::string, std::allocator&lt;std::string&gt;&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#af434a00cfbd2627ea113f6b9286b378f">CXXIter::from</a>(input)</div>
<div class="line">    .collect&lt;std::vector, std::allocator&lt;std::string&gt;&gt;();</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l01148">1148</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>

</div>
</div>
<a id="a116afb3640cb245742403c86fded359f" name="a116afb3640cb245742403c86fded359f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a116afb3640cb245742403c86fded359f">&#9670;&nbsp;</a></span>copied()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::copied </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a new iterator that copies the elements of this iterator. </p>
<p >This function essentially converts an iterator that is passing elements by reference, to an iterator that is passing elements by value midway. </p><dl class="section return"><dt>Returns</dt><dd>A new iterator that is passing copies of the original input elements by value.</dd></dl>
<p>Usage Example: </p><div class="fragment"><div class="line">std::vector&lt;std::string&gt; input = {<span class="stringliteral">&quot;inputString1&quot;</span>, <span class="stringliteral">&quot;inputString2&quot;</span>};</div>
<div class="line">std::vector&lt;std::string&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#af434a00cfbd2627ea113f6b9286b378f">CXXIter::from</a>(input)</div>
<div class="line">    .copied() <span class="comment">// clone values, now working with owned copies instead of references to input</span></div>
<div class="line">    .modify([](std::string&amp; item) { item[item.size() - 1] += 1; }) <span class="comment">// modify copies, input untouched</span></div>
<div class="line">    .collect&lt;std::vector&gt;();</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l01532">1532</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><!-- SVG 1 -->
</div>
</div>

</div>
</div>
<a id="a418901ce726860a7a91bffbc210c1815" name="a418901ce726860a7a91bffbc210c1815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a418901ce726860a7a91bffbc210c1815">&#9670;&nbsp;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Consumer that counts the elements in this iterator. </p>
<dl class="section note"><dt>Note</dt><dd>This consumes the iterator. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The amount of elements in this iterator</dd></dl>
<p>Usage Example: </p><div class="fragment"><div class="line">std::vector&lt;int&gt; input = {42, 1337, 52};</div>
<div class="line"><span class="keywordtype">size_t</span> output = <a class="code hl_function" href="namespaceCXXIter.html#af434a00cfbd2627ea113f6b9286b378f">CXXIter::from</a>(input).count();</div>
<div class="line"><span class="comment">// output == 3</span></div>
<div class="line">std::vector&lt;int&gt; input2 = {};</div>
<div class="line"><span class="keywordtype">size_t</span> output2 = <a class="code hl_function" href="namespaceCXXIter.html#af434a00cfbd2627ea113f6b9286b378f">CXXIter::from</a>(input2).count();</div>
<div class="line"><span class="comment">// output == 0</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l01193">1193</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><!-- SVG 2 -->
</div>
</div>

</div>
</div>
<a id="a7218d94c0c1e6c45dc36abccd57829db" name="a7218d94c0c1e6c45dc36abccd57829db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7218d94c0c1e6c45dc36abccd57829db">&#9670;&nbsp;</a></span>filter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<div class="memtemplate">
template&lt;std::invocable&lt; const <a class="el" href="classCXXIter_1_1IterApi.html#a8242394d80dd375319dda6bc0872d07d">ItemOwned</a> &amp; &gt; TFilterFn&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Filter&lt; TSelf, TFilterFn &gt; <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::filter </td>
          <td>(</td>
          <td class="paramtype">TFilterFn&#160;</td>
          <td class="paramname"><em>filterFn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a new iterator that only contains the elements from this iterator, for which the given <code>filterFn</code> returned <code>true</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filterFn</td><td>Function that decides which element of this iterator to yield in the newly created iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator that only returns the elements for which the <code>filterFn</code> returns <code>true</code>.</dd></dl>
<p>Usage Example: </p><div class="fragment"><div class="line">std::vector&lt;int&gt; input = {1, 2, 3, 4, 5, 6, 7, 8};</div>
<div class="line">std::vector&lt;int&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#af434a00cfbd2627ea113f6b9286b378f">CXXIter::from</a>(input)</div>
<div class="line">    .filter([](<span class="keywordtype">int</span> item) { <span class="keywordflow">return</span> (item % 2) == 0; })</div>
<div class="line">    .collect&lt;std::vector&gt;();</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l01555">1555</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>

</div>
</div>
<a id="a009154287504a68df72425093ee90851" name="a009154287504a68df72425093ee90851"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a009154287504a68df72425093ee90851">&#9670;&nbsp;</a></span>filterMap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<div class="memtemplate">
template&lt;std::invocable&lt; <a class="el" href="classCXXIter_1_1IterApi.html#a8242394d80dd375319dda6bc0872d07d">ItemOwned</a> &amp;&amp; &gt; TFilterMapFn&gt; <br />
requires is_optional&lt;std::invoke_result_t&lt;TFilterMapFn, <a class="el" href="classCXXIter_1_1IterApi.html#a8242394d80dd375319dda6bc0872d07d">ItemOwned</a>&amp;&amp;&gt;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::filterMap </td>
          <td>(</td>
          <td class="paramtype">TFilterMapFn&#160;</td>
          <td class="paramname"><em>filterMapFn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new iterator that filters and maps items from this iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filterMapFn</td><td>Function that maps the incomming items to an optional mapped value. If it returns an empty <code>std::optional&lt;&gt;</code> the element is filtered. If it returns an <code>std::optional&lt;&gt;</code> with a value, that item is yielded from the resulting iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator that yields only the items for which the given <code>filterMapFn</code> returned a mapped value.</dd></dl>
<p>Usage Example: </p><div class="fragment"><div class="line">std::vector&lt;int&gt; input = {1, 2, 3, 4, 5, 6, 7, 8};</div>
<div class="line">std::vector&lt;int&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#af434a00cfbd2627ea113f6b9286b378f">CXXIter::from</a>(input)</div>
<div class="line">    .filterMap([](<span class="keywordtype">int</span> item) -&gt; std::optional&lt;int&gt; {</div>
<div class="line">        <span class="keywordflow">if</span>(item % 2 == 0) { <span class="keywordflow">return</span> (item + 3); }</div>
<div class="line">        <span class="keywordflow">return</span> {};</div>
<div class="line">    })</div>
<div class="line">    .collect&lt;std::vector&gt;();</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l01671">1671</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>

</div>
</div>
<a id="ad8985f7682655e5a925329fcd971b482" name="ad8985f7682655e5a925329fcd971b482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8985f7682655e5a925329fcd971b482">&#9670;&nbsp;</a></span>flatMap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::flatMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an iterator that flattens the iterable elements of this iterator. </p>
<p >This works by pulling elements from this iterator, turning them into iterators themselves, and merging them into the stream of the resulting iterator. This only resolves one layer of nesting, and the elements of this iterator have to be supported by <a class="el" href="namespaceCXXIter.html" title="CXXIter.">CXXIter</a> (by a fitting <code><a class="el" href="structCXXIter_1_1SourceTrait.html" title="SourceTrait, that is used by CXXIter&#39;s standard source classes CXXIter::SrcMov, CXXIter::SrcRef and C...">SourceTrait</a></code> implementation). </p><dl class="section return"><dt>Returns</dt><dd>New iterator that pulls values from this iterator, and flattens the contained iterable into the new iterator's stream.</dd></dl>
<p>Usage Example: </p><div class="fragment"><div class="line">std::vector&lt;std::vector&lt;int&gt;&gt; input = {{1337, 42}, {6, 123, 7888}};</div>
<div class="line">std::vector&lt;int&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#af434a00cfbd2627ea113f6b9286b378f">CXXIter::from</a>(std::move(input))</div>
<div class="line">    .flatMap()</div>
<div class="line">    .collect&lt;std::vector&gt;(); <span class="comment">// collect into vector containing {1337, 42, 6, 123, 7888}</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l01626">1626</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><!-- SVG 3 -->
</div>
</div>

</div>
</div>
<a id="a165695af4dc2acf1cf6eadd3ae6c2fc2" name="a165695af4dc2acf1cf6eadd3ae6c2fc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a165695af4dc2acf1cf6eadd3ae6c2fc2">&#9670;&nbsp;</a></span>flatMap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<div class="memtemplate">
template&lt;std::invocable&lt; <a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a> &amp;&amp; &gt; TFlatMapFn&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::flatMap </td>
          <td>(</td>
          <td class="paramtype">TFlatMapFn&#160;</td>
          <td class="paramname"><em>mapFn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an iterator that works like <a class="el" href="classCXXIter_1_1IterApi.html#ad8f3454d96494c248abf2e740442e6b6" title="Creates an iterator that uses the given mapFn to map each element from this iterator to elements of t...">map()</a>, but flattens nested containers. </p>
<p >This works by pulling elements from this iterator, passing them to the given <code>mapFn</code>, and then taking the returned values to turn them into iterators themselves, to merge them into the stream of the resulting iterator. This only resolves one layer of nesting, and values returned by <code>mapFn</code> have to be supported by <a class="el" href="namespaceCXXIter.html" title="CXXIter.">CXXIter</a> (by a fitting <code><a class="el" href="structCXXIter_1_1SourceTrait.html" title="SourceTrait, that is used by CXXIter&#39;s standard source classes CXXIter::SrcMov, CXXIter::SrcRef and C...">SourceTrait</a></code> implementation). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mapFn</td><td>Function that returns a nesting container, that should be merged into the returned iterator's stream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New iterator that pulls values from this iterator, maps them to a nested container, which is then flattened into the new iterator's stream of elements.</dd></dl>
<p>Usage Example: </p><div class="fragment"><div class="line">std::vector&lt;std::pair&lt;std::string, std::vector&lt;int&gt;&gt;&gt; input = {{<span class="stringliteral">&quot;first pair&quot;</span>, {1337, 42}}, {<span class="stringliteral">&quot;second pair&quot;</span>, {6, 123, 7888}}};</div>
<div class="line">std::vector&lt;int&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#af434a00cfbd2627ea113f6b9286b378f">CXXIter::from</a>(std::move(input))</div>
<div class="line">    .flatMap([](<span class="keyword">auto</span>&amp;&amp; item) { <span class="keywordflow">return</span> std::get&lt;1&gt;(item); }) <span class="comment">// flatten the std::vector&lt;int&gt; from the pair</span></div>
<div class="line">    .collect&lt;std::vector&gt;(); <span class="comment">// collect into vector containing {1337, 42, 6, 123, 7888}</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l01604">1604</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>

</div>
</div>
<a id="a16bc04471483e7ce71726036befa551e" name="a16bc04471483e7ce71726036befa551e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16bc04471483e7ce71726036befa551e">&#9670;&nbsp;</a></span>fold()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<div class="memtemplate">
template&lt;typename TResult , std::invocable&lt; TResult &amp;, <a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a> &amp;&amp; &gt; FoldFn&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TResult <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::fold </td>
          <td>(</td>
          <td class="paramtype">TResult&#160;</td>
          <td class="paramname"><em>startValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FoldFn&#160;</td>
          <td class="paramname"><em>foldFn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Consumer that executes the given <code>foldFn</code> for each item in this iterator, to apply to a working value, which is passed on and passed as second argument to the next call to <code>foldFn</code>. </p>
<dl class="section note"><dt>Note</dt><dd>This consumes the iterator. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startValue</td><td>The initial value of the working value passed to <code>foldFn</code>. </td></tr>
    <tr><td class="paramname">foldFn</td><td>Function called for each element in this iterator, passed the current workingValue and an element from this iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The workingValue from the last call to <code>foldFn</code> for the last element from this iterator.</dd></dl>
<p>Usage Example: </p><div class="fragment"><div class="line">   std::vector&lt;double&gt; input = {1.331335363800390, 1.331335363800390, 1.331335363800390, 1.331335363800390};</div>
<div class="line">   <span class="keywordtype">double</span> output = <a class="code hl_function" href="namespaceCXXIter.html#af434a00cfbd2627ea113f6b9286b378f">CXXIter::from</a>(input)</div>
<div class="line">       .fold(1.0, [](<span class="keywordtype">double</span>&amp; workingValue, <span class="keywordtype">double</span> item) {</div>
<div class="line">           workingValue *= item;</div>
<div class="line">       });</div>
<div class="line"><span class="comment">// output ~ 3.141592653589793</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l01172">1172</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><!-- SVG 4 -->
</div>
</div>

</div>
</div>
<a id="aad1cbb262290264fc2e12d80492ad066" name="aad1cbb262290264fc2e12d80492ad066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad1cbb262290264fc2e12d80492ad066">&#9670;&nbsp;</a></span>forEach()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<div class="memtemplate">
template&lt;typename TUseFn &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::forEach </td>
          <td>(</td>
          <td class="paramtype">TUseFn&#160;</td>
          <td class="paramname"><em>useFn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Consumer that calls the given function <code>useFn</code> for each of the elements in this iterator. </p>
<dl class="section note"><dt>Note</dt><dd>This consumes the iterator. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">useFn</td><td>Function called for each of the elements in this iterator.</td></tr>
  </table>
  </dd>
</dl>
<p>Usage Example: </p><div class="fragment"><div class="line">std::vector&lt;std::string&gt; input = {<span class="stringliteral">&quot;1337&quot;</span>, <span class="stringliteral">&quot;42&quot;</span>, <span class="stringliteral">&quot;64&quot;</span>};</div>
<div class="line">std::vector&lt;std::string&gt; output;</div>
<div class="line"><a class="code hl_function" href="namespaceCXXIter.html#af434a00cfbd2627ea113f6b9286b378f">CXXIter::from</a>(input)</div>
<div class="line">        .forEach([&amp;output](std::string&amp; item) {</div>
<div class="line">            output.push_back(std::forward&lt;std::string&gt;(item));</div>
<div class="line">        });</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l01116">1116</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>

</div>
</div>
<a id="a3da71f522eb2a4e2177c9edb3bc713d5" name="a3da71f522eb2a4e2177c9edb3bc713d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3da71f522eb2a4e2177c9edb3bc713d5">&#9670;&nbsp;</a></span>groupBy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<div class="memtemplate">
template&lt;std::invocable&lt; const <a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a> &amp; &gt; TGroupIdentifierFn&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::groupBy </td>
          <td>(</td>
          <td class="paramtype">TGroupIdentifierFn&#160;</td>
          <td class="paramname"><em>groupIdentFn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Groups the elements of this iterator according to the values returned by the given <code>groupidentFn</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">groupIdentFn</td><td>Function called for each element from this iterator, to determine the grouping value, that is then used to identify the group an item belongs to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New iterator whose elements are the calculated groups from the values of this iterator, in the form of a <code>std::pair&lt;&gt;</code> with the group identifier as first value, and a <code>std::vector</code> of all values in the group as second value. </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>GroupBy requires to first drain the input iterator, before being able to supply a single element. This leads to additional memory usage.</dd></dl>
<p>Usage Example: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>CakeMeasurement {</div>
<div class="line">   std::string cakeType;</div>
<div class="line">   <span class="keywordtype">float</span> cakeWeight;</div>
<div class="line">   <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> CakeMeasurement&amp; o)<span class="keyword"> const </span>{</div>
<div class="line">       <span class="keywordflow">return</span> cakeType == o.cakeType &amp;&amp; cakeWeight == o.cakeWeight;</div>
<div class="line">   }</div>
<div class="line">};</div>
<div class="line">std::vector&lt;CakeMeasurement&gt; input = { {<span class="stringliteral">&quot;ApplePie&quot;</span>, 1.3f}, {<span class="stringliteral">&quot;Sacher&quot;</span>, 0.5f}, {<span class="stringliteral">&quot;ApplePie&quot;</span>, 1.8f} };</div>
<div class="line">std::unordered_map&lt;std::string, std::vector&lt;CakeMeasurement&gt;&gt;  output = <a class="code hl_function" href="namespaceCXXIter.html#af434a00cfbd2627ea113f6b9286b378f">CXXIter::from</a>(input)</div>
<div class="line">   .groupBy([](<span class="keyword">const</span> CakeMeasurement&amp; item) { <span class="keywordflow">return</span> item.cakeType; })</div>
<div class="line">   .collect&lt;std::unordered_map&gt;();</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l01817">1817</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>

</div>
</div>
<a id="a44b0b9e08a32e3f1003857ece564fb82" name="a44b0b9e08a32e3f1003857ece564fb82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44b0b9e08a32e3f1003857ece564fb82">&#9670;&nbsp;</a></span>last()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<div class="memtemplate">
template&lt;typename _unused  = ItemOwned&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classCXXIter_1_1IterApi.html#a8242394d80dd375319dda6bc0872d07d">ItemOwned</a> &gt; <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::last </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Consumer that yields the last element of this iterator. </p>
<dl class="section note"><dt>Note</dt><dd>This consumes the iterator. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The last element of this iterator (if any).</dd></dl>
<p>Usage Example:</p><ul>
<li>For a non-empty iterator <div class="fragment"><div class="line">std::vector&lt;int&gt; input = {42, 1337, 52};</div>
<div class="line">std::optional&lt;int&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#af434a00cfbd2627ea113f6b9286b378f">CXXIter::from</a>(input).last();</div>
<div class="line"><span class="comment">// output == Some(52)</span></div>
</div><!-- fragment --></li>
<li>For an empty iterator: <div class="fragment"><div class="line">std::vector&lt;int&gt; input = {};</div>
<div class="line">std::optional&lt;int&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#af434a00cfbd2627ea113f6b9286b378f">CXXIter::from</a>(input).last();</div>
<div class="line"><span class="comment">// output == None</span></div>
</div><!-- fragment --> </li>
</ul>

<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l01488">1488</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><!-- SVG 5 -->
</div>
</div>

</div>
</div>
<a id="ad8f3454d96494c248abf2e740442e6b6" name="ad8f3454d96494c248abf2e740442e6b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8f3454d96494c248abf2e740442e6b6">&#9670;&nbsp;</a></span>map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<div class="memtemplate">
template&lt;std::invocable&lt; <a class="el" href="classCXXIter_1_1IterApi.html#a8242394d80dd375319dda6bc0872d07d">ItemOwned</a> &amp;&amp; &gt; TMapFn&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::map </td>
          <td>(</td>
          <td class="paramtype">TMapFn&#160;</td>
          <td class="paramname"><em>mapFn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an iterator that uses the given <code>mapFn</code> to map each element from this iterator to elements of the new iterator. </p>
<p >This pulls a new value from this iterator, maps it to a new value (can have a completely new type) using the given <code>mapFn</code> and then yields that as new item for thew newly created iterator. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mapFn</td><td>Function that maps items from this iterator to a new value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New iterator that maps the values from this iterator to new values, using the given <code>mapFn</code>.</dd></dl>
<p>Usage Example: </p><div class="fragment"><div class="line">std::vector&lt;int&gt; input = {1337, 42};</div>
<div class="line">std::unordered_map&lt;int, std::string&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#af434a00cfbd2627ea113f6b9286b378f">CXXIter::from</a>(input)</div>
<div class="line">    .map([](<span class="keywordtype">int</span> i) { <span class="keywordflow">return</span> std::make_pair(i, std::to_string(i)); }) <span class="comment">// construct pair</span></div>
<div class="line">    .collect&lt;std::unordered_map&gt;(); <span class="comment">// collect into map</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l01578">1578</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>

</div>
</div>
<a id="a7704878b20d80e80a913911314e095b1" name="a7704878b20d80e80a913911314e095b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7704878b20d80e80a913911314e095b1">&#9670;&nbsp;</a></span>max()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<div class="memtemplate">
template&lt;typename TResult  = ItemOwned&gt; <br />
requires requires(TResult res, <a class="el" href="classCXXIter_1_1IterApi.html#a8242394d80dd375319dda6bc0872d07d">ItemOwned</a> item) { { item &gt; res }; { res = item }; }</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; TResult &gt; <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::max </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Consumer that yields the largest element from this iterator. </p>
<dl class="section note"><dt>Note</dt><dd>This consumes the iterator. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The largest element of this iterator (if any).</dd></dl>
<p>Usage Example:</p><ul>
<li>For a non-empty iterator <div class="fragment"><div class="line">std::vector&lt;int&gt; input = {42, 1337, 52};</div>
<div class="line">std::optional&lt;int&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#af434a00cfbd2627ea113f6b9286b378f">CXXIter::from</a>(input).max();</div>
<div class="line"><span class="comment">// output == Some(1337)</span></div>
</div><!-- fragment --></li>
<li>For an empty iterator: <div class="fragment"><div class="line">std::vector&lt;int&gt; input = {};</div>
<div class="line">std::optional&lt;int&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#af434a00cfbd2627ea113f6b9286b378f">CXXIter::from</a>(input).max();</div>
<div class="line"><span class="comment">// output == None</span></div>
</div><!-- fragment --> </li>
</ul>

<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l01374">1374</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><!-- SVG 6 -->
</div>
</div>

</div>
</div>
<a id="a793d9ebfadf1f1266605bff81b98fd33" name="a793d9ebfadf1f1266605bff81b98fd33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a793d9ebfadf1f1266605bff81b98fd33">&#9670;&nbsp;</a></span>maxBy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<div class="memtemplate">
template&lt;typename TMaxValueExtractFn &gt; <br />
requires requires(const std::invoke_result_t&lt;TMaxValueExtractFn, const <a class="el" href="classCXXIter_1_1IterApi.html#a8242394d80dd375319dda6bc0872d07d">ItemOwned</a>&amp;&gt;&amp; a) { { a &gt; a }; }</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classCXXIter_1_1IterApi.html#a8242394d80dd375319dda6bc0872d07d">ItemOwned</a> &gt; <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::maxBy </td>
          <td>(</td>
          <td class="paramtype">TMaxValueExtractFn&#160;</td>
          <td class="paramname"><em>minValueExtractFn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Consumer that yields the largest element from this iterator. Comparison of items is done using the comparison values returned by invoking the given <code>minValueExtractFn</code> on each element. </p>
<dl class="section note"><dt>Note</dt><dd>This consumes the iterator. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The largest element of this iterator (if any), compared by the comparison value returned by <code>minValueExtractFn</code>.</dd></dl>
<p>Usage Example:</p><ul>
<li>For a non-empty iterator <div class="fragment"><div class="line">   std::vector&lt;std::string&gt; input = {<span class="stringliteral">&quot;smol&quot;</span>, <span class="stringliteral">&quot;middle&quot;</span>, <span class="stringliteral">&quot;largeString&quot;</span>};</div>
<div class="line">   std::optional&lt;std::string&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#af434a00cfbd2627ea113f6b9286b378f">CXXIter::from</a>(input)</div>
<div class="line">           .maxBy([](<span class="keyword">const</span> std::string&amp; str) { <span class="keywordflow">return</span> str.size(); });</div>
<div class="line"><span class="comment">// output == Some(&quot;largeString&quot;)</span></div>
</div><!-- fragment --></li>
<li>For an empty iterator: <div class="fragment"><div class="line">   std::vector&lt;std::string&gt; input = {};</div>
<div class="line">   std::optional&lt;std::string&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#af434a00cfbd2627ea113f6b9286b378f">CXXIter::from</a>(input)</div>
<div class="line">           .maxBy([](<span class="keyword">const</span> std::string&amp; str) { <span class="keywordflow">return</span> str.size(); });</div>
<div class="line"><span class="comment">// output == None</span></div>
</div><!-- fragment --> </li>
</ul>

<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l01453">1453</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><!-- SVG 7 -->
</div>
</div>

</div>
</div>
<a id="ab96a0fdc7efba2f4bddfa013429bc6bc" name="ab96a0fdc7efba2f4bddfa013429bc6bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab96a0fdc7efba2f4bddfa013429bc6bc">&#9670;&nbsp;</a></span>mean()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<div class="memtemplate">
template&lt;typename TResult  = ItemOwned, typename TCount  = ItemOwned&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; TResult &gt; <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::mean </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Consumer that calculates the mean of all elements of this iterator. </p>
<p >The mean is calculated by first summing up all elements, and then dividing through the number of elements counted while summing. </p><dl class="section note"><dt>Note</dt><dd>This consumes the iterator. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The mean of all elements of this iterator. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TResult</td><td>Type of the mean-calculation's result. This is also the type used for the sum of all elements. </td></tr>
    <tr><td class="paramname">TCount</td><td>Type the element counter is converted into, before dividing the sum by. This can be necessary, if TResult is a complex object that only supports the division operator for e.g. double.</td></tr>
  </table>
  </dd>
</dl>
<p>Usage Example:</p><ul>
<li>For a non-empty iterator <div class="fragment"><div class="line">std::vector&lt;float&gt; input = {1.0f, 2.0f, 3.0f};</div>
<div class="line">std::optional&lt;float&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#af434a00cfbd2627ea113f6b9286b378f">CXXIter::from</a>(input).mean();</div>
<div class="line"><span class="comment">// output == Some(2.0f)</span></div>
</div><!-- fragment --></li>
<li>For an empty iterator: <div class="fragment"><div class="line">std::vector&lt;float&gt; input = {};</div>
<div class="line">std::optional&lt;float&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#af434a00cfbd2627ea113f6b9286b378f">CXXIter::from</a>(input).mean();</div>
<div class="line"><span class="comment">// output == None</span></div>
</div><!-- fragment --> </li>
</ul>

<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l01306">1306</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><!-- SVG 8 -->
</div>
</div>

</div>
</div>
<a id="a9f98bcc96bc3b93477045dabc085c733" name="a9f98bcc96bc3b93477045dabc085c733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f98bcc96bc3b93477045dabc085c733">&#9670;&nbsp;</a></span>min()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<div class="memtemplate">
template&lt;typename TResult  = ItemOwned&gt; <br />
requires requires(TResult res, <a class="el" href="classCXXIter_1_1IterApi.html#a8242394d80dd375319dda6bc0872d07d">ItemOwned</a> item) { { item &lt; res }; { res = item }; }</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; TResult &gt; <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::min </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Consumer that yields the smallest element from this iterator. </p>
<dl class="section note"><dt>Note</dt><dd>This consumes the iterator. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The smallest element of this iterator (if any).</dd></dl>
<p>Usage Example:</p><ul>
<li>For a non-empty iterator <div class="fragment"><div class="line">std::vector&lt;int&gt; input = {42, 1337, 52};</div>
<div class="line">std::optional&lt;int&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#af434a00cfbd2627ea113f6b9286b378f">CXXIter::from</a>(input).min();</div>
<div class="line"><span class="comment">// output == Some(42)</span></div>
</div><!-- fragment --></li>
<li>For an empty iterator: <div class="fragment"><div class="line">std::vector&lt;int&gt; input = {};</div>
<div class="line">std::optional&lt;int&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#af434a00cfbd2627ea113f6b9286b378f">CXXIter::from</a>(input).min();</div>
<div class="line"><span class="comment">// output == None</span></div>
</div><!-- fragment --> </li>
</ul>

<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l01340">1340</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><!-- SVG 9 -->
</div>
</div>

</div>
</div>
<a id="af11b6d97680a8e6a080261b51ff67fe6" name="af11b6d97680a8e6a080261b51ff67fe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af11b6d97680a8e6a080261b51ff67fe6">&#9670;&nbsp;</a></span>minBy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<div class="memtemplate">
template&lt;typename TMinValueExtractFn &gt; <br />
requires requires(const std::invoke_result_t&lt;TMinValueExtractFn, const <a class="el" href="classCXXIter_1_1IterApi.html#a8242394d80dd375319dda6bc0872d07d">ItemOwned</a>&amp;&gt;&amp; a) { { a &lt; a }; }</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classCXXIter_1_1IterApi.html#a8242394d80dd375319dda6bc0872d07d">ItemOwned</a> &gt; <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::minBy </td>
          <td>(</td>
          <td class="paramtype">TMinValueExtractFn&#160;</td>
          <td class="paramname"><em>minValueExtractFn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Consumer that yields the smallest element from this iterator. Comparison of items is done using the comparison values returned by invoking the given <code>minValueExtractFn</code> on each element. </p>
<dl class="section note"><dt>Note</dt><dd>This consumes the iterator. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The smallest element of this iterator (if any), compared by the comparison value returned by <code>minValueExtractFn</code>.</dd></dl>
<p>Usage Example:</p><ul>
<li>For a non-empty iterator <div class="fragment"><div class="line">   std::vector&lt;std::string&gt; input = {<span class="stringliteral">&quot;smol&quot;</span>, <span class="stringliteral">&quot;middle&quot;</span>, <span class="stringliteral">&quot;largeString&quot;</span>};</div>
<div class="line">   std::optional&lt;std::string&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#af434a00cfbd2627ea113f6b9286b378f">CXXIter::from</a>(input)</div>
<div class="line">           .minBy([](<span class="keyword">const</span> std::string&amp; str) { <span class="keywordflow">return</span> str.size(); });</div>
<div class="line"><span class="comment">// output == Some(&quot;smol&quot;)</span></div>
</div><!-- fragment --></li>
<li>For an empty iterator: <div class="fragment"><div class="line">   std::vector&lt;std::string&gt; input = {};</div>
<div class="line">   std::optional&lt;std::string&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#af434a00cfbd2627ea113f6b9286b378f">CXXIter::from</a>(input)</div>
<div class="line">           .minBy([](<span class="keyword">const</span> std::string&amp; str) { <span class="keywordflow">return</span> str.size(); });</div>
<div class="line"><span class="comment">// output == None</span></div>
</div><!-- fragment --> </li>
</ul>

<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l01411">1411</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><!-- SVG 10 -->
</div>
</div>

</div>
</div>
<a id="a48bef0687a6d677acbfa59d6a49b17c3" name="a48bef0687a6d677acbfa59d6a49b17c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48bef0687a6d677acbfa59d6a49b17c3">&#9670;&nbsp;</a></span>modify()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<div class="memtemplate">
template&lt;std::invocable&lt; <a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a> &amp; &gt; TModifierFn&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">InplaceModifier&lt; TSelf, TModifierFn &gt; <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::modify </td>
          <td>(</td>
          <td class="paramtype">TModifierFn&#160;</td>
          <td class="paramname"><em>modifierFn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows to inspect and modify each item in-place, that passes through this iterator. </p>
<p >This can be used instead of a <a class="el" href="classCXXIter_1_1IterApi.html#ad8f3454d96494c248abf2e740442e6b6" title="Creates an iterator that uses the given mapFn to map each element from this iterator to elements of t...">map()</a> with the same type as input and output. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">modifierFn</td><td>Function that is called for each item that passes through this iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator that forwards the items of this iterator, after they have been inspected and potentially modified by the <code>modifierFn</code>.</dd></dl>
<p>Usage Example: </p><div class="fragment"><div class="line">std::unordered_map&lt;int, std::string&gt; input = { {1337, <span class="stringliteral">&quot;1337&quot;</span>}, {42, <span class="stringliteral">&quot;42&quot;</span>} };</div>
<div class="line">std::unordered_map&lt;int, std::string&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#af434a00cfbd2627ea113f6b9286b378f">CXXIter::from</a>(input)</div>
<div class="line">    .modify([](<span class="keyword">auto</span>&amp; keyValue) { keyValue.second = <span class="stringliteral">&quot;-&quot;</span> + keyValue.second; }) <span class="comment">// modify input</span></div>
<div class="line">    .collect&lt;std::unordered_map&gt;(); <span class="comment">// copy to output</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l01646">1646</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>

</div>
</div>
<a id="a9baddc40de1b9c63102e5c5bf886474e" name="a9baddc40de1b9c63102e5c5bf886474e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9baddc40de1b9c63102e5c5bf886474e">&#9670;&nbsp;</a></span>sizeHint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCXXIter_1_1SizeHint.html">SizeHint</a> <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::sizeHint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l01093">1093</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>

</div>
</div>
<a id="ad616d50fe5b01eb2fdbfe02ced9cc2a1" name="ad616d50fe5b01eb2fdbfe02ced9cc2a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad616d50fe5b01eb2fdbfe02ced9cc2a1">&#9670;&nbsp;</a></span>skip()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::skip </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cnt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an iterator that skips the first <code>cnt</code> elements from this iterator, before it yields the remaining items. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cnt</td><td>Amount of elements to skip from this iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new iterator that skips <code>cnt</code> elements from this iterator, before yielding the remaining items.</dd></dl>
<p>Usage Example: </p><div class="fragment"><div class="line">std::vector&lt;int&gt; input = {42, 42, 42, 42, 1337};</div>
<div class="line">std::vector&lt;int&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#af434a00cfbd2627ea113f6b9286b378f">CXXIter::from</a>(input)</div>
<div class="line">    .skip(3) <span class="comment">// skip first 3 values</span></div>
<div class="line">    .collect&lt;std::vector&gt;();</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l01690">1690</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>

</div>
</div>
<a id="a2a6a0f58078b8797c3ede1e6ec3896ce" name="a2a6a0f58078b8797c3ede1e6ec3896ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a6a0f58078b8797c3ede1e6ec3896ce">&#9670;&nbsp;</a></span>skipWhile()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<div class="memtemplate">
template&lt;std::invocable&lt; const <a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a> &amp; &gt; TSkipPredicate&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SkipWhile&lt; TSelf, TSkipPredicate &gt; <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::skipWhile </td>
          <td>(</td>
          <td class="paramtype">TSkipPredicate&#160;</td>
          <td class="paramname"><em>skipPredicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an iterator that skips the first elements of this iterator, for which the given <code>skipPredicate</code> returns <code>true</code>. </p>
<p >The <code>skipPredicate</code> is only called until it returned <code>false</code> for the first time, after that its job is done. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">skipPredicate</td><td>Predicate that determines the items whether an item at the beginning of this iterator should be skipped (<code>true</code>). Should return <code>false</code> for the first item yielded from the resulted iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new iterator that skips the frist elements from this iterator, until the given <code>skipPredicate</code> returns <code>false</code> for the first time. It then yields all remaining items of this iterator.</dd></dl>
<p>Usage Example: </p><div class="fragment"><div class="line">std::vector&lt;int&gt; input = {42, 42, 42, 42, 1337, 42};</div>
<div class="line">std::vector&lt;int&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#af434a00cfbd2627ea113f6b9286b378f">CXXIter::from</a>(input)</div>
<div class="line">    .skipWhile([](<span class="keyword">const</span> <span class="keywordtype">int</span> value) { <span class="keywordflow">return</span> (value == 42); }) <span class="comment">// skip leading 42s</span></div>
<div class="line">    .collect&lt;std::vector&gt;();</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l01719">1719</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>

</div>
</div>
<a id="a6c92644bc9fdae0fdc0795e0cfbda883" name="a6c92644bc9fdae0fdc0795e0cfbda883"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c92644bc9fdae0fdc0795e0cfbda883">&#9670;&nbsp;</a></span>sorted() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="namespaceCXXIter.html#a36594d1d501e0f5fc7d80174fc82e42c">SortOrder</a> ORDER = SortOrder::ASCENDING, bool STABLE = false&gt; <br />
requires requires(const <a class="el" href="classCXXIter_1_1IterApi.html#a8242394d80dd375319dda6bc0872d07d">ItemOwned</a>&amp; a) { { a &lt; a }; { a &gt; a }; }</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::sorted </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new iterator that takes the items from this iterator, and passes them on sorted. </p>
<dl class="section note"><dt>Note</dt><dd>This variant of <a class="el" href="classCXXIter_1_1IterApi.html#a6c92644bc9fdae0fdc0795e0cfbda883" title="Creates a new iterator that takes the items from this iterator, and passes them on sorted.">sorted()</a> requires the items to support comparison operators. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>New iterator that returns the items of this iterator sorted. </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Sorter requires to first drain the input iterator, before being able to supply a single element. This leads to additional memory usage. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ORDER</td><td>Decides the sort order of the resulting iterator. </td></tr>
    <tr><td class="paramname">STABLE</td><td>If <code>true</code>, uses <code>std::stable_sort</code> internally, if <code>false</code> uses <code>std::sort</code> </td></tr>
  </table>
  </dd>
</dl>
<p>Usage Example:</p><ul>
<li>Sorting in ascending order using a custom comparer: <div class="fragment"><div class="line">std::vector&lt;float&gt; input = {1.0f, 2.0f, 0.5f, 3.0f, -42.0f};</div>
<div class="line">std::vector&lt;float&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#af434a00cfbd2627ea113f6b9286b378f">CXXIter::from</a>(input)</div>
<div class="line">    .sorted&lt;CXXIter::ASCENDING, <span class="keyword">false</span>&gt;()</div>
<div class="line">    .collect&lt;std::vector&gt;();</div>
</div><!-- fragment --></li>
<li>Sorting in descending order using a custom comparer: <div class="fragment"><div class="line">std::vector&lt;float&gt; input = {1.0f, 2.0f, 0.5f, 3.0f, -42.0f};</div>
<div class="line">std::vector&lt;float&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#af434a00cfbd2627ea113f6b9286b378f">CXXIter::from</a>(input)</div>
<div class="line">    .sorted&lt;CXXIter::DESCENDING, <span class="keyword">false</span>&gt;()</div>
<div class="line">    .collect&lt;std::vector&gt;();</div>
</div><!-- fragment --> </li>
</ul>

<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l01883">1883</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>

</div>
</div>
<a id="a25568f12125a97a9579508a5cf5e7bd6" name="a25568f12125a97a9579508a5cf5e7bd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25568f12125a97a9579508a5cf5e7bd6">&#9670;&nbsp;</a></span>sorted() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<div class="memtemplate">
template&lt;bool STABLE, std::invocable&lt; const <a class="el" href="classCXXIter_1_1IterApi.html#a8242394d80dd375319dda6bc0872d07d">ItemOwned</a> &amp;, const <a class="el" href="classCXXIter_1_1IterApi.html#a8242394d80dd375319dda6bc0872d07d">ItemOwned</a> &amp; &gt; TCompareFn&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::sorted </td>
          <td>(</td>
          <td class="paramtype">TCompareFn&#160;</td>
          <td class="paramname"><em>compareFn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new iterator that takes the items from this iterator, and passes them on sorted, using the supplied <code>compareFn</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compareFn</td><td>Compare function used for the sorting of items. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New iterator that returns the items of this iterator sorted using the given <code>compareFn</code>. </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Sorter requires to first drain the input iterator, before being able to supply a single element. This leads to additional memory usage. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">STABLE</td><td>If <code>true</code>, uses <code>std::stable_sort</code> internally, if <code>false</code> uses <code>std::sort</code> </td></tr>
  </table>
  </dd>
</dl>
<p>Usage Example:</p><ul>
<li>Sorting in ascending order using a custom comparer: <div class="fragment"><div class="line">std::vector&lt;float&gt; input = {1.0f, 2.0f, 0.5f, 3.0f, -42.0f};</div>
<div class="line">std::vector&lt;float&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#af434a00cfbd2627ea113f6b9286b378f">CXXIter::from</a>(input)</div>
<div class="line">    .sorted&lt;<span class="keyword">false</span>&gt;([](<span class="keyword">const</span> <span class="keywordtype">float</span>&amp; a, <span class="keyword">const</span> <span class="keywordtype">float</span>&amp; b) {</div>
<div class="line">        <span class="keywordflow">return</span> (a &lt; b);</div>
<div class="line">    })</div>
<div class="line">    .collect&lt;std::vector&gt;();</div>
</div><!-- fragment --></li>
<li>Sorting in descending order using a custom comparer: <div class="fragment"><div class="line">std::vector&lt;float&gt; input = {1.0f, 2.0f, 0.5f, 3.0f, -42.0f};</div>
<div class="line">std::vector&lt;float&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#af434a00cfbd2627ea113f6b9286b378f">CXXIter::from</a>(input)</div>
<div class="line">    .sorted&lt;<span class="keyword">false</span>&gt;([](<span class="keyword">const</span> <span class="keywordtype">float</span>&amp; a, <span class="keyword">const</span> <span class="keywordtype">float</span>&amp; b) {</div>
<div class="line">        <span class="keywordflow">return</span> (a &gt; b);</div>
<div class="line">    })</div>
<div class="line">    .collect&lt;std::vector&gt;();</div>
</div><!-- fragment --> </li>
</ul>

<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l01852">1852</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>

</div>
</div>
<a id="a90fcf438abe534c819b846b6a3fbf8c1" name="a90fcf438abe534c819b846b6a3fbf8c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90fcf438abe534c819b846b6a3fbf8c1">&#9670;&nbsp;</a></span>sortedBy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="namespaceCXXIter.html#a36594d1d501e0f5fc7d80174fc82e42c">SortOrder</a> ORDER = SortOrder::ASCENDING, bool STABLE = false, std::invocable&lt; const <a class="el" href="classCXXIter_1_1IterApi.html#a8242394d80dd375319dda6bc0872d07d">ItemOwned</a> &amp; &gt; TSortValueExtractFn&gt; <br />
requires requires(const std::invoke_result_t&lt;TSortValueExtractFn, const <a class="el" href="classCXXIter_1_1IterApi.html#a8242394d80dd375319dda6bc0872d07d">ItemOwned</a>&amp;&gt;&amp; a) { { a &lt; a }; { a &gt; a }; }</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::sortedBy </td>
          <td>(</td>
          <td class="paramtype">TSortValueExtractFn&#160;</td>
          <td class="paramname"><em>sortValueExtractFn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new iterator that takes the items from this iterator, and passes them on sorted. </p>
<p >In comparison to <a class="el" href="classCXXIter_1_1IterApi.html#a6c92644bc9fdae0fdc0795e0cfbda883" title="Creates a new iterator that takes the items from this iterator, and passes them on sorted.">sorted()</a>, which either uses a custom comparator or the items themselves for the sort operation, this variant takes a <code>sortValueExtractFn</code>, which extracts a value for each item in this iterator, that should be used for sorting comparisons. </p><dl class="section return"><dt>Returns</dt><dd>New iterator that returns the items of this iterator sorted. </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Sorter requires to first drain the input iterator, before being able to supply a single element. This leads to additional memory usage. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ORDER</td><td>Decides the sort order of the resulting iterator. </td></tr>
    <tr><td class="paramname">STABLE</td><td>If <code>true</code>, uses <code>std::stable_sort</code> internally, if <code>false</code> uses <code>std::sort</code> </td></tr>
  </table>
  </dd>
</dl>
<p>Usage Example:</p><ul>
<li>Sorting the items(strings) in ascending order of their length: <div class="fragment"><div class="line">std::vector&lt;std::string&gt; input = {<span class="stringliteral">&quot;test1&quot;</span>, <span class="stringliteral">&quot;test2&quot;</span>, <span class="stringliteral">&quot;test23&quot;</span>, <span class="stringliteral">&quot;test&quot;</span>, <span class="stringliteral">&quot;tes&quot;</span>};</div>
<div class="line">std::vector&lt;std::string&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#af434a00cfbd2627ea113f6b9286b378f">CXXIter::from</a>(input)</div>
<div class="line">    .sortedBy&lt;CXXIter::ASCENDING, <span class="keyword">true</span>&gt;([](<span class="keyword">const</span> std::string&amp; item) { <span class="keywordflow">return</span> item.size(); })</div>
<div class="line">    .collect&lt;std::vector&gt;();</div>
</div><!-- fragment --></li>
<li>Sorting the items(strings) in descending order of their length: <div class="fragment"><div class="line">std::vector&lt;std::string&gt; input = {<span class="stringliteral">&quot;test1&quot;</span>, <span class="stringliteral">&quot;test2&quot;</span>, <span class="stringliteral">&quot;test23&quot;</span>, <span class="stringliteral">&quot;test&quot;</span>, <span class="stringliteral">&quot;tes&quot;</span>};</div>
<div class="line">std::vector&lt;std::string&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#af434a00cfbd2627ea113f6b9286b378f">CXXIter::from</a>(input)</div>
<div class="line">    .sortedBy&lt;CXXIter::DESCENDING, <span class="keyword">true</span>&gt;([](<span class="keyword">const</span> std::string&amp; item) { <span class="keywordflow">return</span> item.size(); })</div>
<div class="line">    .collect&lt;std::vector&gt;();</div>
</div><!-- fragment --> </li>
</ul>

<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l01924">1924</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>

</div>
</div>
<a id="ab5674bb7c86728cc2520d7b3bebea437" name="ab5674bb7c86728cc2520d7b3bebea437"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5674bb7c86728cc2520d7b3bebea437">&#9670;&nbsp;</a></span>stringJoin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::stringJoin </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>separator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Consumer that concatenates the elements of this iterator to a large <code>std::string</code> , where each element is separated by the specified <code>separator</code>. </p>
<dl class="section note"><dt>Note</dt><dd>This consumes the iterator. </dd>
<dd>
This method is only available for iterators whose elements are <code>std::string</code> . If that is not the case, convert your items to <code>std::string</code> s first, using a method like <code><a class="el" href="classCXXIter_1_1IterApi.html#ad8f3454d96494c248abf2e740442e6b6" title="Creates an iterator that uses the given mapFn to map each element from this iterator to elements of t...">map()</a></code>. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting string concatenation of all items of this iterator.</dd></dl>
<p>Usage Example:</p><ul>
<li>Non-empty iterator with default startValue <div class="fragment"><div class="line">std::vector&lt;int&gt; input = {42, 1337, 52};</div>
<div class="line"><span class="keywordtype">int</span> output = <a class="code hl_function" href="namespaceCXXIter.html#af434a00cfbd2627ea113f6b9286b378f">CXXIter::from</a>(input).sum();</div>
<div class="line"><span class="comment">// output == 1431</span></div>
</div><!-- fragment --></li>
<li>Non-Empty iterator with custom startValue of 29906 <div class="fragment"><div class="line">std::vector&lt;int&gt; input = {42, 1337, 52};</div>
<div class="line"><span class="keywordtype">int</span> output = <a class="code hl_function" href="namespaceCXXIter.html#af434a00cfbd2627ea113f6b9286b378f">CXXIter::from</a>(input).sum(29906);</div>
<div class="line"><span class="comment">// output == 31337</span></div>
</div><!-- fragment --></li>
<li>Empty iterator with default startValue <div class="fragment"><div class="line">std::vector&lt;int&gt; input = {};</div>
<div class="line"><span class="keywordtype">int</span> output = <a class="code hl_function" href="namespaceCXXIter.html#af434a00cfbd2627ea113f6b9286b378f">CXXIter::from</a>(input).sum();</div>
<div class="line"><span class="comment">// output == 0</span></div>
</div><!-- fragment --></li>
<li>Empty iterator with custom startValue <div class="fragment"><div class="line">std::vector&lt;int&gt; input = {};</div>
<div class="line"><span class="keywordtype">int</span> output = <a class="code hl_function" href="namespaceCXXIter.html#af434a00cfbd2627ea113f6b9286b378f">CXXIter::from</a>(input).sum(31337);</div>
<div class="line"><span class="comment">// output == 31337</span></div>
</div><!-- fragment --> </li>
</ul>

<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l01270">1270</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><!-- SVG 11 -->
</div>
</div>

</div>
</div>
<a id="a69c182f266a918168975a3764a1fc8eb" name="a69c182f266a918168975a3764a1fc8eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69c182f266a918168975a3764a1fc8eb">&#9670;&nbsp;</a></span>sum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<div class="memtemplate">
template&lt;typename TResult  = ItemOwned&gt; <br />
requires requires(TResult res, <a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a> item) { { res += item }; }</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TResult <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::sum </td>
          <td>(</td>
          <td class="paramtype">TResult&#160;</td>
          <td class="paramname"><em>startValue</em> = <code>TResult()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Consumer that calculates the sum of all elements from this iterator. </p>
<dl class="section note"><dt>Note</dt><dd>This consumes the iterator. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startValue</td><td>Starting value from which to start the sum. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of all elements from this iterator, or <code>startValue</code> if this iterator had no elements.</dd></dl>
<p>Usage Example:</p><ul>
<li>Non-empty iterator with default startValue <div class="fragment"><div class="line">std::vector&lt;int&gt; input = {42, 1337, 52};</div>
<div class="line"><span class="keywordtype">int</span> output = <a class="code hl_function" href="namespaceCXXIter.html#af434a00cfbd2627ea113f6b9286b378f">CXXIter::from</a>(input).sum();</div>
<div class="line"><span class="comment">// output == 1431</span></div>
</div><!-- fragment --></li>
<li>Non-Empty iterator with custom startValue of 29906 <div class="fragment"><div class="line">std::vector&lt;int&gt; input = {42, 1337, 52};</div>
<div class="line"><span class="keywordtype">int</span> output = <a class="code hl_function" href="namespaceCXXIter.html#af434a00cfbd2627ea113f6b9286b378f">CXXIter::from</a>(input).sum(29906);</div>
<div class="line"><span class="comment">// output == 31337</span></div>
</div><!-- fragment --></li>
<li>Empty iterator with default startValue <div class="fragment"><div class="line">std::vector&lt;int&gt; input = {};</div>
<div class="line"><span class="keywordtype">int</span> output = <a class="code hl_function" href="namespaceCXXIter.html#af434a00cfbd2627ea113f6b9286b378f">CXXIter::from</a>(input).sum();</div>
<div class="line"><span class="comment">// output == 0</span></div>
</div><!-- fragment --></li>
<li>Empty iterator with custom startValue <div class="fragment"><div class="line">std::vector&lt;int&gt; input = {};</div>
<div class="line"><span class="keywordtype">int</span> output = <a class="code hl_function" href="namespaceCXXIter.html#af434a00cfbd2627ea113f6b9286b378f">CXXIter::from</a>(input).sum(31337);</div>
<div class="line"><span class="comment">// output == 31337</span></div>
</div><!-- fragment --> </li>
</ul>

<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l01232">1232</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><!-- SVG 12 -->
</div>
</div>

</div>
</div>
<a id="a36ee6ce2e84839b2e353bb83b07a64c2" name="a36ee6ce2e84839b2e353bb83b07a64c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36ee6ce2e84839b2e353bb83b07a64c2">&#9670;&nbsp;</a></span>take()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::take </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cnt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an iterator that yields at most the first <code>cnt</code> elements from this iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cnt</td><td>Amount of elements to yield from this iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new iterator that yields only at most the first <code>cnt</code> elements from this iterator.</dd></dl>
<p>Usage Example: </p><div class="fragment"><div class="line">std::vector&lt;int&gt; input = {42, 57, 64, 128, 1337, 10};</div>
<div class="line">std::vector&lt;int&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#af434a00cfbd2627ea113f6b9286b378f">CXXIter::from</a>(input)</div>
<div class="line">    .take(3) <span class="comment">// take first 3 values</span></div>
<div class="line">    .collect&lt;std::vector&gt;();</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l01736">1736</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>

</div>
</div>
<a id="ab16a10f60f2eddc85f29974d04672ba4" name="ab16a10f60f2eddc85f29974d04672ba4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab16a10f60f2eddc85f29974d04672ba4">&#9670;&nbsp;</a></span>takeWhile()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<div class="memtemplate">
template&lt;std::invocable&lt; const <a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a> &amp; &gt; TTakePredicate&gt; <br />
requires std::is_same_v&lt;std::invoke_result_t&lt;TTakePredicate, const <a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">Item</a>&amp;&gt;, bool&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::takeWhile </td>
          <td>(</td>
          <td class="paramtype">TTakePredicate&#160;</td>
          <td class="paramname"><em>takePredicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an iterator that yields the first elements of this iterator, for which the given <code>takePredicate</code> returns <code>true</code>. </p>
<p >The <code>takePredicate</code> is only called until it returned <code>false</code> for the first time, after that its job is done. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">takePredicate</td><td>Predicate that determines the items returned by the newly constructed iterator. After this predicate yielded <code>false</code> for the first time, the new iterator ends. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new iterator that yields the first couple elements from this iterator, until the given predicate returns <code>false</code> for the first time.</dd></dl>
<p>Usage Example: </p><div class="fragment"><div class="line">std::vector&lt;int&gt; input = {42, 57, 64, 128, 1337, 10};</div>
<div class="line">std::vector&lt;int&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#af434a00cfbd2627ea113f6b9286b378f">CXXIter::from</a>(input)</div>
<div class="line">    .takeWhile([](<span class="keyword">const</span> <span class="keywordtype">int</span> value) { <span class="keywordflow">return</span> (value &lt; 1000); }) <span class="comment">// take until first item &gt; 1000</span></div>
<div class="line">    .collect&lt;std::vector&gt;();</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l01763">1763</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>

</div>
</div>
<a id="ae49eef0f6493a206d6db38c05e36dbed" name="ae49eef0f6493a206d6db38c05e36dbed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae49eef0f6493a206d6db38c05e36dbed">&#9670;&nbsp;</a></span>zip()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CXXIterIterator TSelf&gt; </div>
<div class="memtemplate">
template&lt;typename TOtherIterator &gt; <br />
requires (!std::is_reference_v&lt;typename IteratorTrait&lt;TOtherIterator&gt;<a class="el" href="classCXXIter_1_1IterApi.html#a00f3ed5b2201522d327c6a8a92d371c8">::Item</a>&gt; &amp;&amp; !IS_REFERENCE)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Zipper&lt; TSelf, TOtherIterator &gt; <a class="el" href="classCXXIter_1_1IterApi.html">CXXIter::IterApi</a>&lt; TSelf &gt;::zip </td>
          <td>(</td>
          <td class="paramtype">TOtherIterator &amp;&amp;&#160;</td>
          <td class="paramname"><em>otherIterator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>"Zips up" two <a class="el" href="namespaceCXXIter.html" title="CXXIter.">CXXIter</a> iterators into a single iterator over pairs from both iterators. </p>
<p >Constructs new iterator that iterates over <code>std::pair&lt;&gt;</code> instances where values from this iterator are put in the first value, and values from the given <code>otherIterator</code> become the second values. The resulting iterator is only as long as the shorter of both zipped iterators. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">otherIterator</td><td>Second iterator zipped against this iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New iterator that zips together this iteratore and the given <code>otherIterator</code> into a new iterator over <code>std::pair&lt;&gt;</code> for both zipped iterator's values.</dd></dl>
<p>Usage Example: </p><div class="fragment"><div class="line">std::vector&lt;std::string&gt; input1 = {<span class="stringliteral">&quot;1337&quot;</span>, <span class="stringliteral">&quot;42&quot;</span>};</div>
<div class="line">std::vector&lt;int&gt; input2 = {1337, 42};</div>
<div class="line">std::vector&lt;std::pair&lt;std::string, int&gt;&gt; output = <a class="code hl_function" href="namespaceCXXIter.html#af434a00cfbd2627ea113f6b9286b378f">CXXIter::from</a>(input1).copied()</div>
<div class="line">   .zip(<a class="code hl_function" href="namespaceCXXIter.html#af434a00cfbd2627ea113f6b9286b378f">CXXIter::from</a>(input2).<a class="code hl_function" href="classCXXIter_1_1IterApi.html#a116afb3640cb245742403c86fded359f">copied</a>())</div>
<div class="line">   .collect&lt;std::vector&gt;();</div>
<div class="ttc" id="aclassCXXIter_1_1IterApi_html_a116afb3640cb245742403c86fded359f"><div class="ttname"><a href="classCXXIter_1_1IterApi.html#a116afb3640cb245742403c86fded359f">CXXIter::IterApi::copied</a></div><div class="ttdeci">auto copied()</div><div class="ttdoc">Constructs a new iterator that copies the elements of this iterator.</div><div class="ttdef"><b>Definition:</b> <a href="CXXIter_8h_source.html#l01532">CXXIter.h:1532</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="CXXIter_8h_source.html#l01787">1787</a> of file <a class="el" href="CXXIter_8h_source.html">CXXIter.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/CXXIter/<a class="el" href="CXXIter_8h_source.html">CXXIter.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceCXXIter.html">CXXIter</a></li><li class="navelem"><a class="el" href="classCXXIter_1_1IterApi.html">IterApi</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
  </ul>
</div>
</body>
</html>
